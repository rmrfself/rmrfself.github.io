<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="http://localhost:4000/tag/architecture/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2019-04-11T15:30:04+08:00</updated>
  <id>http://localhost:4000/tag/architecture/feed.xml</id>

  
  
  

  
    <title type="html">张庆华的个人日志 | </title>
  

  
    <subtitle>Learn, Innovate, Share - Business Based Vision.</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">对开发方式的思考</title>
      <link href="http://localhost:4000/archi-architect-org" rel="alternate" type="text/html" title="对开发方式的思考" />
      <published>2016-02-11T22:10:11+08:00</published>
      <updated>2016-02-11T22:10:11+08:00</updated>
      <id>http://localhost:4000/archi-architect-org</id>
      <content type="html" xml:base="http://localhost:4000/archi-architect-org">&lt;p&gt;由为什么我需要迭代引起的思考。&lt;/p&gt;

&lt;h4 id=&quot;开发的目标是什么the-target-of-dev&quot;&gt;开发的目标是什么(the target of dev)？&lt;/h4&gt;

&lt;h5 id=&quot;双层交互人与环境之间的信息交换&quot;&gt;双层交互(人与环境之间的信息交换)&lt;/h5&gt;

&lt;p&gt;开发的目标是为了实现人和工具的交互，工具和工具之间的交互。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.h5tube.com/why-iterate.png&quot; alt=&quot;人机交互&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;对效率的思考&quot;&gt;对效率的思考&lt;/h5&gt;

&lt;p&gt;迭代的过程把复杂问题分解成可实现、可部署的小的升级过程。&lt;/p&gt;

&lt;p&gt;这里的问题是， 不同的团队背景的“复杂问题”是不同的。&lt;/p&gt;

&lt;h5 id=&quot;产品定义初期的复杂问题&quot;&gt;产品定义初期的“复杂问题”&lt;/h5&gt;

&lt;p&gt;产品或者工具本身带来的不确定性。&lt;/p&gt;

&lt;p&gt;&amp;lt; 根本原因是，市场需求的本质是盲目的。&amp;gt;&lt;/p&gt;

&lt;p&gt;这对开发者来说， 从市场反馈的信息也是“相对盲目”的。 需要“决断”过程。&lt;/p&gt;

&lt;p&gt;这种产品定义的决断过程一般不是快速“升级”可解决的。&lt;/p&gt;

&lt;p&gt;所以， 对开发者来讲， 产品定义初期， 需要整理出一份“代码清单”：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;哪些是可复用的？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对移动产品来讲， 基础通信框架和UI定义方式是可复用的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;哪些是临时的？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;业务实现逻辑是临时的。&lt;/p&gt;

&lt;h5 id=&quot;产品或者工具发展过程中的复杂问题&quot;&gt;产品或者工具发展过程中的“复杂问题”&lt;/h5&gt;

&lt;p&gt;这个过程，用户量从1到N， 系统复杂度度从1到N&lt;/p&gt;

&lt;p&gt;这里带来的“复杂问题”是， 如何做反馈？&lt;/p&gt;

&lt;p&gt;有价值的东西并不是N的用户量， 而是1到N的增长率带来的反馈信息。如何捕捉这种信息？&lt;/p&gt;

&lt;h5 id=&quot;产品或者工具问题基本稳定后的复杂问题&quot;&gt;产品或者工具问题“基本稳定”后的复杂问题&lt;/h5&gt;

&lt;p&gt;这个过程的复杂问题是”稳定性“, 如何修复系统问题性？&lt;/p&gt;

&lt;p&gt;这里，稳定性包括： 系统升级稳定性和系统降级稳定性。&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="architecture" />
      

      
        <summary type="html">由为什么我需要迭代引起的思考。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">论什么是软件架构?</title>
      <link href="http://localhost:4000/archi-architect-who" rel="alternate" type="text/html" title="论什么是软件架构?" />
      <published>2016-02-10T20:29:11+08:00</published>
      <updated>2016-02-10T20:29:11+08:00</updated>
      <id>http://localhost:4000/archi-architect-who</id>
      <content type="html" xml:base="http://localhost:4000/archi-architect-who">&lt;p&gt;架构的核心内容是什么?&lt;/p&gt;

&lt;h4 id=&quot;架构的原则objectives&quot;&gt;架构的原则(Objectives)&lt;/h4&gt;

&lt;p&gt;总体原则&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.h5tube.com/architecture-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从架构的角度看(下面箭头方向)，推荐的架构原则&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;(1) 面向变化设计&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(2) 面向风险设计&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(3) 模型化 + 可视化(这是为什么mvc经久不衰的原因，它同时满足了两个要求)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(4) 面向进化设计&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;架构的过程&quot;&gt;架构的过程&lt;/h4&gt;

&lt;p&gt;架构不是一个东西(not a thing, not a tool)，它是一个最优路径规划和设计的过程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;(1) 组织过程。 它为团队成员(stakeholders)提供沟通桥梁。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(2) 早期决策，架构价值的重要体现。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;好的架构表现&quot;&gt;好的架构表现&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;(1) 测试的完整性，满足质量要求&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(2) 安全。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;安全的竞争壁垒的保障，属于“守”的一方。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;(3) 满足性能能要求。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;架构必须满足时空要求&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;(4) 用户友好&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用者友好，满足人类情感要求，至少不排斥。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;(5) 可扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;潜在的满足时空要求&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;(6) 可维护&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;使异常可控制， 满足内部安全性要求。&lt;/p&gt;
&lt;/blockquote&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="architecture" />
      

      
        <summary type="html">架构的核心内容是什么?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Postgres的流复制</title>
      <link href="http://localhost:4000/archi-postgresql" rel="alternate" type="text/html" title="Postgres的流复制" />
      <published>2015-02-10T11:17:10+08:00</published>
      <updated>2015-02-10T11:17:10+08:00</updated>
      <id>http://localhost:4000/archi-postgresql</id>
      <content type="html" xml:base="http://localhost:4000/archi-postgresql">&lt;h3 id=&quot;流复制起源&quot;&gt;流复制起源&lt;/h3&gt;

&lt;p&gt;PostgreSQL 自从2010年推出的9.0版本开始，支持流式物理复制，用户可以通过流式复制，构建只读备库(主备物理复制，块级别一致)。流式物理复制可以做到极低的延迟（通常在1毫秒以内）。&lt;/p&gt;

&lt;h3 id=&quot;同步流复制&quot;&gt;同步流复制&lt;/h3&gt;

&lt;p&gt;2011年推出的9.1版本，支持同步复制，当时只支持一个同步流复制备节点（例如配置了3个备，只有一个是同步模式的，其他都是异步模式）。&lt;/p&gt;

&lt;p&gt;在同步复制模式下，当用户提交事务时，需要等待这笔事务的WAL日志复制到同步流复制备节点，才会返回提交成功的ACK给客户端。&lt;/p&gt;

&lt;p&gt;同步模式下，可以确保数据的0丢失。（只要客户端收到了事务提交成功的ACK，这笔事务的WAL就有两份。）&lt;/p&gt;

&lt;h3 id=&quot;级联流复制&quot;&gt;级联流复制&lt;/h3&gt;

&lt;p&gt;2012年推出的9.2版本，支持级联流复制。意思是备库还可以再连备库。&lt;/p&gt;

&lt;p&gt;级联复制特别适合跨机房的使用，例如主库在A机房，备库在B机房，但是B机房需要建立多个备库时，那么B机房只需要建立一个直连主库的备库，其他的备库可以通过B机房的这个备库级联产生。从而减少网络开销。&lt;/p&gt;

&lt;h3 id=&quot;流式虚拟备库&quot;&gt;流式虚拟备库&lt;/h3&gt;

&lt;p&gt;2012年推出的9.2版本，除了支持级联复制，还支持虚拟备库，什么是虚拟备库呢？就是只有WAL，没有数据文件的备库。&lt;/p&gt;

&lt;p&gt;通过虚拟备库，可以流式的接收WAL，进行实时的流式WAL归档。提高备份或归档的实时性。&lt;/p&gt;

&lt;h3 id=&quot;逻辑复制的基础&quot;&gt;逻辑复制的基础&lt;/h3&gt;

&lt;p&gt;2014年推出的9.4版本，在WAL中增加了逻辑复制需要的基础信息，通过插件，可以实现逻辑复制。&lt;/p&gt;

&lt;p&gt;逻辑复制可以做到对主库的部分复制，例如表级复制，而不是整个集群的块级一致复制。&lt;/p&gt;

&lt;p&gt;逻辑复制的备库不仅仅是只读的，也可以执行写操作。&lt;/p&gt;

&lt;h3 id=&quot;增加几种同步级别&quot;&gt;增加几种同步级别&lt;/h3&gt;

&lt;p&gt;2016年推出的9.6版本，PG的流式复制，通过复制WAL达到同步的目的，因此同步级别也和WAL有关。通过synchronous_commit参数，可以配置事务的同步级别。&lt;/p&gt;

&lt;p&gt;1、on, 表示本地WAL fsync，同步standby WAL fsync。即两份持久化的WAL。&lt;/p&gt;

&lt;p&gt;2、remote_apply, 表示本地WAL fsync，同步standby WAL 已恢复。这个带来的RT最高。&lt;/p&gt;

&lt;p&gt;3、remote_write, 表示本地WAL fsync，同步standby WAL 异步write完成。一份持久化，备库的WAL可能还在OS CACHE中。&lt;/p&gt;

&lt;p&gt;4、local, 表示本地WAL fsync。&lt;/p&gt;

&lt;p&gt;5、off, 表示本地WAL写到wal buffer中即返回客户端事务提交成功的ACK，为异步提交（数据库CRASH可能导致事务丢失，但不会导致数据库不一致）。&lt;/p&gt;

&lt;p&gt;RT影响，从低到高如下：&lt;/p&gt;

&lt;p&gt;off, local, remote_write, on, remote_apply。&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="architecture" />
      

      
        <summary type="html">流复制起源</summary>
      

      
      
    </entry>
  
</feed>
