<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="http://localhost:4000/tag/jvm/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2019-04-19T12:11:09+08:00</updated>
  <id>http://localhost:4000/tag/jvm/feed.xml</id>

  
  
  

  
    <title type="html">张庆华的个人日志 | </title>
  

  
    <subtitle>Learn, Innovate, Share - Business Based Vision.</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">消息中间件-RabbitMQ应用模式解析(二)</title>
      <link href="http://localhost:4000/event-based-archi" rel="alternate" type="text/html" title="消息中间件-RabbitMQ应用模式解析(二)" />
      <published>2018-01-21T22:00:10+08:00</published>
      <updated>2018-01-21T22:00:10+08:00</updated>
      <id>http://localhost:4000/event-based-archi</id>
      <content type="html" xml:base="http://localhost:4000/event-based-archi">&lt;p&gt;消息中间件解析。&lt;/p&gt;

&lt;h4 id=&quot;架构上的差异&quot;&gt;架构上的差异&lt;/h4&gt;

&lt;h5 id=&quot;layer-based-architecture&quot;&gt;Layer based architecture&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/MVC-Process.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从设计上看，基于分层的应用架构设计，比如 Model-controller-view ，或者 前端的model-(view-model-mediator)-view 模式，本质上是一种&lt;code class=&quot;highlighter-rouge&quot;&gt;同步&lt;/code&gt;设计思想。&lt;/p&gt;

&lt;h5 id=&quot;event-based-archtecture&quot;&gt;Event based archtecture&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/events.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基于事件(event-based)的架构设计，本质上是对应用或者不同实体的状态的订阅和处理。&lt;/p&gt;

&lt;p&gt;基于web 事件的常规设计模式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/webevents.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为什么微服务架构下，异步消息引擎变得如此重要?&lt;/p&gt;

&lt;p&gt;关系型数据可以看做对状态空间的持久化，消息中间件是状态的异步处理引擎。&lt;/p&gt;

&lt;p&gt;kafka综合了上述两类特点。&lt;/p&gt;

&lt;p&gt;大数据背景下，除了数据本身的状态变得重要之外，状态之间的关系也非常重要。特别是不同类型的实体之间的关联。经典段子是沃尔玛&lt;code class=&quot;highlighter-rouge&quot;&gt;啤酒和尿不湿&lt;/code&gt;销量的调查。&lt;/p&gt;

&lt;h5 id=&quot;rabbitmq的特性&quot;&gt;RabbitMQ的特性&lt;/h5&gt;

&lt;p&gt;消息中间件重要的特性:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;合并和分组消息，在rabbitmq中有exchange组件实现，也成为消息路由。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;RabbitMq对消息分组做了2层抽象:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;virtual host&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于多租户的逻辑分组&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;channel&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于TCP连接的逻辑分组。&lt;/p&gt;

&lt;p&gt;RabbitMQ支持4种消息分组或者路由方式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Direct 路由方式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/rabbitmq01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种消息路由方式基于key的&lt;code class=&quot;highlighter-rouge&quot;&gt;相等&lt;/code&gt;匹配模式，是一对一订阅方式的实现。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Fanout 路由方式(广播方式)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/rabbitmq02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种方式是全播方式 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 模式匹配，是1对多订阅方式的实现。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Topic 路由方式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种方式是消息路由&lt;code class=&quot;highlighter-rouge&quot;&gt;多对多&lt;/code&gt;的方式。常用户批处理。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Header 路由方式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于Headers定义属性的、高优先级的订阅-处理方式。&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Event-Driven architecture 是实体、模块、系统间解耦和通信的理想方式。
构建reactive系统架构的基础。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="jvm" />
      

      
        <summary type="html">消息中间件解析。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">spring中的100个问题-bean是被透明化管理的?</title>
      <link href="http://localhost:4000/springboot-how-bean-managed" rel="alternate" type="text/html" title="spring中的100个问题-bean是被透明化管理的?" />
      <published>2016-03-12T23:15:11+08:00</published>
      <updated>2016-03-12T23:15:11+08:00</updated>
      <id>http://localhost:4000/springboot-how-bean-managed</id>
      <content type="html" xml:base="http://localhost:4000/springboot-how-bean-managed">&lt;h2 id=&quot;spring-bean的实现路线图&quot;&gt;Spring bean的实现路线图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring-beans-managed.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;bean在spring内部的表示形式&quot;&gt;bean在spring内部的表示形式&lt;/h4&gt;

&lt;h5 id=&quot;如何理解bean&quot;&gt;如何理解bean&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring-beans-managed01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="jvm" />
      

      
        <summary type="html">Spring bean的实现路线图</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">JVM内部机制(七) Java内存模型(Java Momory Model)</title>
      <link href="http://localhost:4000/jvm-jmm" rel="alternate" type="text/html" title="JVM内部机制(七) Java内存模型(Java Momory Model)" />
      <published>2016-03-12T11:30:15+08:00</published>
      <updated>2016-03-12T11:30:15+08:00</updated>
      <id>http://localhost:4000/jvm-jmm</id>
      <content type="html" xml:base="http://localhost:4000/jvm-jmm">&lt;p&gt;Jvm内存模型解析&lt;/p&gt;

&lt;h2 id=&quot;什么是内存模型&quot;&gt;什么是内存模型&lt;/h2&gt;

&lt;p&gt;Java的内存模型和jvm中的内存layout是两个不同的概念。&lt;/p&gt;

&lt;p&gt;Jvm中的Memory Layout，栈、栈帧、Heap[新生代(New Generation)、旧生代、MetaData区域]是一种内存结构，是为实现Java语言而设计的一种存储结构，它与jvm的运行时状态无关，只要运行Java程序，这种存贮结构就会被用到。&lt;/p&gt;

&lt;p&gt;而JSR133中定义的Java内存模型是Java语言层面的，讨论的核心是指令集(Instruction Set)如何在N个线程(并行执行序列)的背景下，使得每个单一线程以正确、符合预期的方式表达。&lt;/p&gt;

&lt;p&gt;那么，问题来了。&lt;/p&gt;

&lt;p&gt;在什么情况下，指令集会以符合预期的方式运行？相反，什么条件使得结果让人难以接受，为什么？&lt;/p&gt;

&lt;p&gt;Java的内存模型讨论的正是这种问题边界存在原因，以及最佳实践。&lt;/p&gt;

&lt;h2 id=&quot;数据同步的两大问题类型&quot;&gt;数据同步的两大问题类型&lt;/h2&gt;

&lt;p&gt;判断程序是否被正确同步,有两种方法:&lt;/p&gt;

&lt;h3 id=&quot;data-race&quot;&gt;Data Race&lt;/h3&gt;

&lt;p&gt;对共享的字段或者数组元素同时进行R-W(读写)操作,这种情况被称为“数据竞争”(data race)&lt;/p&gt;

&lt;h3 id=&quot;-happen-before-relationship&quot;&gt;⇒ Happen Before Relationship&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Happened-before&quot;&gt;happened-before&lt;/a&gt; 关系定义为:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果一个事件(event) 发生在另外一个事件前， 那么， 它们的结果也是如此。

数学描述为

传递性(transitivity): ∀ a,b,c,如果 a → b, b → c,  那么 a → c 

对任意的a,b,c,  如果a发生在b之前，b发生在c之前， 那么， a 发生在c之前

不自反特性: ∀a, a ↛ a 

动作a不能在自身执行前发生

不对称特性: ∀ a, b , 如果 a ≠ b, 那么 a → b , b ↛ a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Java程序中，固定的Happens-Before动作(actions、method、or sinle instruction)发生的情况有:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同一个线程内，排在前面的指令(actions: read OR write)一定先执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;或者说，同一线程内的动作是顺序执行(SO)的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对监视器(monitor)的解锁动作(un-lock)一定发生在下一个锁动作(lock)之前。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是锁资源的独占特性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对volatile字段的写(W)动作发生在对这个字段的读(R)动作之前&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程启动(Thread.start())发生已启动线程(Treads)的动作(actions)之前&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;某一活动线程的内动作(action)发生其他线程从join()成功返回之前&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动作传递特性&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对任意的a,b,c,  如果a发生在b之前，b发生在c之前， 那么， a 发生在c之前&lt;/p&gt;

&lt;h3 id=&quot;产生数据同步问题的诱因&quot;&gt;产生数据同步问题的诱因&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;变量可见性(Visibility) → 不加控制的共享变量&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class LoopMayNeverEnd {
    boolean done = false;

    // 线程 1
    void work() {
        while (!done) {
        // do work
        }
    }

    // 线程 2
    void stopWork() {
        done = true;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果&lt;/p&gt;

&lt;p&gt;线程1(r) $\xrightarrow[\text{Before}]{\text{happens}}$ 线程2(r)&lt;/p&gt;

&lt;p&gt;那么，上面循环就编程了 while(true)了。&lt;/p&gt;

&lt;p&gt;导致问题的原因是&lt;/p&gt;

&lt;p&gt;线程1使用了其他线程也可以看到的变量。使用前并没有任务预防措施。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ordering → 编译器特权带来的同步问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BadlyOrdered {
    boolean a = false;
    boolean b = false;

    // 线程 1
    void threadOne() {
        a = true;
        b = true;
    }

    // 线程 2
    boolean threadTwo() {
        boolean r1 = b; // sees true
        boolean r2 = a; // sees false
        return r1 &amp;amp;&amp;amp; !r2; // returns true
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述两个类方法缺少同步，这导致了线程2读取a,b的时候， 线程1执行到了一半: a == true, b == false。&lt;/p&gt;

&lt;p&gt;正确的方式应该是确保&lt;/p&gt;

&lt;p&gt;threadOne() $\xrightarrow[\text{Before}]{\text{happens}}$threadTwo()&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;原子性(Atomicity) → 读写的原子性封装&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;同步问题的根源-数据一致性&quot;&gt;同步问题的根源： 数据一致性&lt;/h2&gt;

&lt;h3 id=&quot;区分actions和executions&quot;&gt;区分Actions和Executions&lt;/h3&gt;

&lt;p&gt;一个action被描述为一个tuple&lt;/p&gt;

&lt;p&gt;$⟨t,k,u,v⟩$, 有4种类型的变量定义&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;t → 代表执行动作的线程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;k → 代表同步动作(Synchronization Actions)的类型&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;volatile read

volatile write, 

(normal or non-volatile) read

(normal or non-volatile) write

lock or unlock Volatile reads

volatile writes

locks and unlocks
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;v → 代表被actions用到的monitor或者变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;u → 此次动作的唯一ID&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个执行(Executions)也被定义为一个tuple:&lt;/p&gt;

&lt;p&gt;⟨P,A,$\xrightarrow{po}$,$\xrightarrow{so}$,W,V,$\xrightarrow{\text{sw}}$,$\xrightarrow{\text{hb}}$⟩&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;P → 代表程序或者指令&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A → 一组actions&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$\xrightarrow{po}$ → A中被每个线程执行的actions的程序序列，这里不是指令序列。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;po → 程序顺序指的是编码是代码的定义顺序，这里是所有actions中的po&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$\xrightarrow{so}$ → A中的同步顺序，这里还是程序序列&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;W → 在E中(执行序列中)定义的，可以被读感知到的写动作，记做W(r)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;V → 代表写动作执行后的值。对A中的写动作w，记做V(w),在执行序列E中写入的值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$\xrightarrow{sw}$ → 代表同步关系&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;x $\xrightarrow{synchronizes with}$ y，意味着x与y同步&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
x = r1 (volatile write ⤞ 读取x的值之前，需要x的rlease状态)

y = x (volatile read ⤞ 读取x的值之前要等待x release结束)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;$\xrightarrow{hb}$ → Happens Before 关系&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;同步的定义&quot;&gt;同步的定义&lt;/h3&gt;

&lt;p&gt;如果满足一下条件， 执行序列E被认为是同步的&lt;/p&gt;

&lt;p&gt;1、每次读(read)到的值由执行序列E中的一次W决定。被定义为&lt;/p&gt;

&lt;p&gt;∀ r ∈ A, 使得&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{cases} 
W(r) ∈ A \\
W(r).v == r.v
\end{cases}&lt;/script&gt;

&lt;p&gt;可理解为： 写动作发生在当前E中，读到的值等于写后的值&lt;/p&gt;

&lt;p&gt;2、代码执行顺序po和指令执行顺序同步顺序一致&lt;/p&gt;

&lt;p&gt;不可用存在这种情况:&lt;/p&gt;

&lt;p&gt;x,y ∈ A,  x $\xrightarrow{so}$ y &amp;amp; y $\xrightarrow{po}$ x&lt;/p&gt;

&lt;p&gt;可理解为，对任意x,y 属于A， 不能存在以下情况:&lt;/p&gt;

&lt;p&gt;y同步于x，y的值有x决定。y却又先于x执行&lt;/p&gt;

&lt;p&gt;3、多线程执行服从于单线程指令执行一致性(The execution obeys intra-thread consistency)&lt;/p&gt;

&lt;p&gt;可以理解为&lt;/p&gt;

&lt;p&gt;多线程的执行结果与把多线程改造为单线程执行后的结果一致&lt;/p&gt;

&lt;p&gt;4、多线程服从Happen-before一致性规则&lt;/p&gt;

&lt;h3 id=&quot;被jmm允许的意外情况&quot;&gt;被Jmm允许的意外情况&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jmm-02.png&quot; alt=&quot;jmm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本文解释一下在JDK8中,JVM如何执行方法。&lt;/p&gt;

&lt;h3 id=&quot;todo&quot;&gt;TODO&lt;/h3&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="jvm" />
      

      
        <summary type="html">Jvm内存模型解析</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">spring中的100个问题-bean如何支持运行时类型解析的?</title>
      <link href="http://localhost:4000/springboot-how-bean-type-created" rel="alternate" type="text/html" title="spring中的100个问题-bean如何支持运行时类型解析的?" />
      <published>2016-03-10T22:50:11+08:00</published>
      <updated>2016-03-10T22:50:11+08:00</updated>
      <id>http://localhost:4000/springboot-how-bean-type-created</id>
      <content type="html" xml:base="http://localhost:4000/springboot-how-bean-type-created">&lt;p&gt;什么是spring中的bean? 如何定义或描述?&lt;/p&gt;

&lt;h4 id=&quot;beans&quot;&gt;beans&lt;/h4&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="jvm" />
      

      
        <summary type="html">什么是spring中的bean? 如何定义或描述?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">spring中的100个问题-(spring-beans)bean是如何创建的?</title>
      <link href="http://localhost:4000/springboot-how-bean-created" rel="alternate" type="text/html" title="spring中的100个问题-(spring-beans)bean是如何创建的?" />
      <published>2016-03-10T07:50:11+08:00</published>
      <updated>2016-03-10T07:50:11+08:00</updated>
      <id>http://localhost:4000/springboot-how-bean-created</id>
      <content type="html" xml:base="http://localhost:4000/springboot-how-bean-created">&lt;p&gt;Bean container解决的核心问题是如何在运行时(run-time)动态获取或创建Java Object。&lt;/p&gt;

&lt;h2 id=&quot;bean-container的类图&quot;&gt;Bean Container的类图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/factory-bean.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;spring提供了3中方式创建beans&quot;&gt;spring提供了3中方式创建beans&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/bean-create-instance.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;函数调用堆栈&quot;&gt;函数调用堆栈&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/bean-instance-create.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;autowirecapablebeanfactory-接口&quot;&gt;AutowireCapableBeanFactory 接口&lt;/h4&gt;

&lt;p&gt;Spring-beans模块中使用AutowireCapableBeanFactory接口实现bean的创建和销毁。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;T&amp;gt; T createBean(Class&amp;lt;T&amp;gt; beanClass) throws BeansException;

void autowireBean(Object existingBean) throws BeansException;

Object configureBean(Object existingBean, String beanName) throws BeansException;

Object createBean(Class&amp;lt;?&amp;gt; beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;

Object autowire(Class&amp;lt;?&amp;gt; beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;
void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)
			throws BeansException;

void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException;

Object initializeBean(Object existingBean, String beanName) throws BeansException;

Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
			throws BeansException;

Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
			throws BeansException;

void destroyBean(Object existingBean);

&amp;lt;T&amp;gt; NamedBeanHolder&amp;lt;T&amp;gt; resolveNamedBean(Class&amp;lt;T&amp;gt; requiredType) throws BeansException;

Object resolveDependency(DependencyDescriptor descriptor, String requestingBeanName) throws BeansException;

Object resolveDependency(DependencyDescriptor descriptor, String requestingBeanName,
			Set&amp;lt;String&amp;gt; autowiredBeanNames, TypeConverter typeConverter) throws BeansException;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;beanfactory-接口&quot;&gt;BeanFactory 接口&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;访问spring container的根接口(根界面)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;接口列表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;T&amp;gt; T getBean(String name, Class&amp;lt;T&amp;gt; requiredType) throws BeansException;
&amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) throws BeansException;
Object getBean(String name, Object... args) throws BeansException;
&amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType, Object... args) throws BeansException;
boolean containsBean(String name);
boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
boolean isPrototype(String name) throws NoSuchBeanDefinitionException;
boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
boolean isTypeMatch(String name, Class&amp;lt;?&amp;gt; typeToMatch) throws NoSuchBeanDefinitionException;
Class&amp;lt;?&amp;gt; getType(String name) throws NoSuchBeanDefinitionException;
String[] getAliases(String name);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="jvm" />
      

      
        <summary type="html">Bean container解决的核心问题是如何在运行时(run-time)动态获取或创建Java Object。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">JVM内部机制(六) HotSpot代码导读</title>
      <link href="http://localhost:4000/jvm-source-guide" rel="alternate" type="text/html" title="JVM内部机制(六) HotSpot代码导读" />
      <published>2016-03-08T10:30:02+08:00</published>
      <updated>2016-03-08T10:30:02+08:00</updated>
      <id>http://localhost:4000/jvm-source-guide</id>
      <content type="html" xml:base="http://localhost:4000/jvm-source-guide">&lt;p&gt;Hotspot源码阅读顺序&lt;/p&gt;

&lt;h3 id=&quot;todo&quot;&gt;TODO&lt;/h3&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="jvm" />
      

      
        <summary type="html">Hotspot源码阅读顺序</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">JVM内部机制(五)多线程编程模型中的常见问题</title>
      <link href="http://localhost:4000/jvm-multiple-threads" rel="alternate" type="text/html" title="JVM内部机制(五)多线程编程模型中的常见问题" />
      <published>2016-03-05T12:08:12+08:00</published>
      <updated>2016-03-05T12:08:12+08:00</updated>
      <id>http://localhost:4000/jvm-multiple-threads</id>
      <content type="html" xml:base="http://localhost:4000/jvm-multiple-threads">&lt;p&gt;已转移到java.util.concurrent使用方法解析。&lt;/p&gt;

&lt;h3 id=&quot;什么是threadlocal-它有什么用&quot;&gt;什么是ThreadLocal? 它有什么用?&lt;/h3&gt;

&lt;p&gt;ThreadLocal 是为存储&lt;code class=&quot;highlighter-rouge&quot;&gt;线程独立&lt;/code&gt;的数据而设计的。&lt;/p&gt;

&lt;h3 id=&quot;volatile-关键字的作用是什么&quot;&gt;volatile 关键字的作用是什么?&lt;/h3&gt;

&lt;p&gt;在java实现的volatile版本中(区别于c++中的volatile[易挥发物])，使用这个关键字用来确保所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;读&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;写&lt;/code&gt;在所有线程之间是&lt;code class=&quot;highlighter-rouge&quot;&gt;串行&lt;/code&gt;(顺序执行)的。它也确保了读出的值是&lt;code class=&quot;highlighter-rouge&quot;&gt;实际&lt;/code&gt;的值而不是工作区缓存的值&lt;/p&gt;

&lt;h3 id=&quot;sleep和wait的区别&quot;&gt;sleep和wait的区别&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;wait() 是object类的实例方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sleep(milliseconds)是线程的静态方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;wait()的设计目的是&lt;code class=&quot;highlighter-rouge&quot;&gt;线程间&lt;/code&gt;同步(synchronization)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Thread.sleep的设计目的是暂停当前执行线程，与同步或者锁没有直接关系&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;唤醒方式不同&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;wait()的使用方法:&lt;/p&gt;

&lt;p&gt;被包围在同步块中，线程a调用线程b&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;synchronized (b) {
    while (b.sum == 0) {
        System.out.println(&quot;Waiting for ThreadB to complete...&quot;);
        b.wait();
    }
 
    System.out.println(&quot;ThreadB has completed. &quot; + 
      &quot;Sum from that thread is: &quot; + b.sum);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;唤醒方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int sum;
  
@Override
public void run() {
    synchronized (this) {
        int i = 0;
        while (i &amp;lt; 100000) {
            sum += i;
            i++; 
        }
        notify(); 
    } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="jvm" />
      

      
        <summary type="html">已转移到java.util.concurrent使用方法解析。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">JVM内部机制(四)Java中的线程</title>
      <link href="http://localhost:4000/jvm-thread" rel="alternate" type="text/html" title="JVM内部机制(四)Java中的线程" />
      <published>2016-02-18T02:05:45+08:00</published>
      <updated>2016-02-18T02:05:45+08:00</updated>
      <id>http://localhost:4000/jvm-thread</id>
      <content type="html" xml:base="http://localhost:4000/jvm-thread">&lt;p&gt;POSIX.equals(“Portable Operating System Interface”)&lt;/p&gt;

&lt;h2 id=&quot;os中进程和线程&quot;&gt;OS中进程和线程&lt;/h2&gt;

&lt;h3 id=&quot;线程基础&quot;&gt;线程基础&lt;/h3&gt;

&lt;p&gt;进程是对资源的抽象，包括CPU、内存、IO操作、文件描述符等，是系统资源分配的最小单元。&lt;/p&gt;

&lt;p&gt;线程是对调度和执行的抽象，是调度的最小单元。&lt;/p&gt;

&lt;p&gt;线程是在进程内部运行的执行分支，每个线程对应一个独立的执行分支。&lt;/p&gt;

&lt;p&gt;从执行角度看，线程是为了共享资源（共享地址空间），进程是为了资源独占（私有地址空间）。&lt;/p&gt;

&lt;p&gt;按照代码执行的位置区分，可以把线程分为3种:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;用户空间线程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内核(kernel)空间线程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Fibers(常被翻译为纤程)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上3种资源调度方式如果独立使用，弊大于利。&lt;/p&gt;

&lt;p&gt;比如，内核对纯用户空间的线程无感知。 当线程执行到IO时，产生系统调用，从而在内核空间被block。 整个进程内的所有线程都要一起等到IO完成后才可以继续执行。&lt;/p&gt;

&lt;p&gt;如果把用户线程和内核线程混合使用，可以取长补短。这样就产生了线程调度模型。&lt;/p&gt;

&lt;h3 id=&quot;线程调度模型&quot;&gt;线程调度模型&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/thread-model-design.png&quot; alt=&quot;线程调度模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;线程的调度方式目前的实现主要有两种:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;抢占式(preemptive)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/thread-preemptive-mode.png&quot; alt=&quot;抢占式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;抢占式线程有内核主动调度并负责上下文切换。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;协作式(cooperative)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/thread-cooperate-mode.png&quot; alt=&quot;协作式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;协作式线程最大的特点是调度权有线程自己决定，所以不存在并发和同步引起的问题。&lt;/p&gt;

&lt;p&gt;缺点是协作线程无法把握下一次被执行的时间。&lt;/p&gt;

&lt;h3 id=&quot;轻量级进程-lwp&quot;&gt;轻量级进程-LWP&lt;/h3&gt;

&lt;h4 id=&quot;lightweight-progress&quot;&gt;Lightweight Progress&lt;/h4&gt;

&lt;p&gt;在linux的实现中，用户线程和lwp之间是1:1的关系。lwp为用户空间内的线程陷入内核的系统调用提供了一个管道。&lt;/p&gt;

&lt;p&gt;使用ps -eLf 命令可以查看系统内的LWP列表:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD
root         1     0     1  0    1 Oct18 ?        00:00:36 /sbin/init splash
root         2     0     2  0    1 Oct18 ?        00:00:00 [kthreadd]
root         4     2     4  0    1 Oct18 ?        00:00:00 [kworker/0:0H]
root         6     2     6  0    1 Oct18 ?        00:00:00 [mm_percpu_wq]s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;lwp在内核内体现为一个task_struct链。&lt;/p&gt;

&lt;p&gt;task_struct结构体类似Jvm中的instance_oop对象，是一个多层次链，用来存储运行时需要的所有资源引用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/task_struct.png&quot; alt=&quot;task_struct&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;用户线程&quot;&gt;用户线程&lt;/h3&gt;

&lt;p&gt;用户线程指的是完全建立在用户空间的线程库，它的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。所以，这种线程的操作是极其快速的且低消耗的。&lt;/p&gt;

&lt;h2 id=&quot;jvm中的执行结构&quot;&gt;Jvm中的执行结构&lt;/h2&gt;

&lt;h3 id=&quot;线程&quot;&gt;线程&lt;/h3&gt;

&lt;p&gt;在linux平台上，jvm内的线程模型也是1对1的关系&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jvm-thread-frame.png&quot; alt=&quot;jvm thread model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考文献&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://cs.nyu.edu/courses/fall09/G22.2250-001/class-notes.html&quot;&gt;G22.2250 Operating Systems&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/cd/E19455-01/806-5257/mtintro-72944/index.html&quot;&gt;Multithreaded Programming Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.it.uu.se/education/course/homepage/os/vt18/&quot;&gt;Operating systems&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="jvm" />
      

      
        <summary type="html">POSIX.equals(“Portable Operating System Interface”)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">JVM 内部机制(三)调试工具集</title>
      <link href="http://localhost:4000/jvm-debug-tool" rel="alternate" type="text/html" title="JVM 内部机制(三)调试工具集" />
      <published>2016-02-05T20:50:00+08:00</published>
      <updated>2016-02-05T20:50:00+08:00</updated>
      <id>http://localhost:4000/jvm-debug-tool</id>
      <content type="html" xml:base="http://localhost:4000/jvm-debug-tool">&lt;p&gt;JVM运行时调试工具集&lt;/p&gt;

&lt;h3 id=&quot;todo&quot;&gt;TODO&lt;/h3&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="jvm" />
      

      
        <summary type="html">JVM运行时调试工具集</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">JVM中的常见约定</title>
      <link href="http://localhost:4000/jvm-internals" rel="alternate" type="text/html" title="JVM中的常见约定" />
      <published>2016-01-23T15:05:10+08:00</published>
      <updated>2016-01-23T15:05:10+08:00</updated>
      <id>http://localhost:4000/jvm-internals</id>
      <content type="html" xml:base="http://localhost:4000/jvm-internals">&lt;p&gt;Language is just like a puppet.&lt;/p&gt;

&lt;h3 id=&quot;在类签名中-v-是什么意思&quot;&gt;在类签名中 “()V” 是什么意思?&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The JVM uses a compact way of storing method signatures, of which constructors are considered a special case.

For your example:

() indicates a method taking no arguments
V indicates that it returns nothing
The other parts of the scheme are:

B - byte
C - char
D - double
F - float
I - int
J - long
S - short
V - void
Z - boolean
[ - array of the thing following the bracket
L [class name] ; - instance of this class, with dots becoming slashes
( [args] ) [return type] - method signature
For example:

public int foo(String bar, long[][] baz)
would become

(Ljava/lang/String;[[J)I
See the spec at Sun^H^H^HOracle's web site
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;union用法示例&quot;&gt;union用法示例&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;

union var{        
    long int l;        
    int i;
};

main(){        
    union var v;        
    v.l = 5;        
    printf(&quot;v.l is %d\n&quot;,v.i);        
    v.i = 6;        
    printf(&quot;now v.l is %ld! the address is %p\n&quot;,v.l,&amp;amp;v.l);        
    printf(&quot;now v.i is %d! the address is %p\n&quot;,v.i,&amp;amp;v.;
}

结果：v.l is 5now v.l is 6! the address is 0xbfad1e2c

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="jvm" />
      

      
        <summary type="html">Language is just like a puppet.</summary>
      

      
      
    </entry>
  
</feed>
