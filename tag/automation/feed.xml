<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="http://localhost:4000/tag/automation/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2019-04-19T13:09:30+08:00</updated>
  <id>http://localhost:4000/tag/automation/feed.xml</id>

  
  
  

  
    <title type="html">张庆华的个人日志 | </title>
  

  
    <subtitle>Learn, Innovate, Share - Business Based Vision.</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">Aws中基于vpc网络结构解析</title>
      <link href="http://localhost:4000/devops-aws-vpc" rel="alternate" type="text/html" title="Aws中基于vpc网络结构解析" />
      <published>2018-12-29T21:01:01+08:00</published>
      <updated>2018-12-29T21:01:01+08:00</updated>
      <id>http://localhost:4000/devops-aws-vpc</id>
      <content type="html" xml:base="http://localhost:4000/devops-aws-vpc">&lt;h5 id=&quot;计费规则&quot;&gt;计费规则&lt;/h5&gt;

&lt;p&gt;VPC定义的所有功能组件，包括路由表、子网定义、安全规则都是免费的。&lt;/p&gt;

&lt;h5 id=&quot;规划vpc&quot;&gt;规划VPC&lt;/h5&gt;

&lt;p&gt;规划vpc时，通常考虑以下几点:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在同一个vpc中划分子网&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如，按互联网产品的交付方式分，把子网按照不同的网段分为Dev(开发环境)、Testing(staging测试环境)、Product(生产环境)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vpc-structure.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;按照地理区域划分网络&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;vpc中各组件的使用方法&quot;&gt;VPC中各组件的使用方法&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;弹性网络接口(Elastic Network Interfaces)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个组件是对硬件网卡的抽象，包含网络协议地址(v4、v6、Mac地址)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;路由表(Route table)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;路由表是子网(subnet)的一个重要的&lt;code class=&quot;highlighter-rouge&quot;&gt;逻辑组件&lt;/code&gt;(VPC内的组件是抽象的逻辑组件)。它是连接子网内的实例 和 网关的重要凭证。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;路由表的核心作用是指定&amp;lt;源(source)---data---目的地(destination)&amp;gt;封装后的数据包发往何方。

跨网络的数据需要发到网关(gateway)，由网关决定数据的下一站。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;VPC中包含一个&lt;code class=&quot;highlighter-rouge&quot;&gt;默认的路由表&lt;/code&gt;，也成为主路由(main route)。&lt;/p&gt;

&lt;p&gt;通常在建立子网时，如果不指定路由，子网会默认使用VPC的默认路由。&lt;/p&gt;

&lt;p&gt;下图两个子网都默认连接到了VPC内部的默认路由。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/routing-Route_Replace_Main_Start-diagramrouting-Route_Replace_Main_Start-diagram.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网关(gateway)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vpc中有两种常用网关&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;internet gateway&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nat gateway&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Internet gateway是VPC中常用的网关,它的特点是允许数据双向进出。&lt;/p&gt;

&lt;p&gt;连接到internet gateway的子网称为 public network。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/internet-gateway-overview-diagram.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有另外一种网关是Nat Gateway。 如果一个子网的路由绑定到了nat gateway，它称为private network。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/nat-gateway-diagram.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;从安全的角度看vpc&quot;&gt;从安全的角度看VPC&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vpc-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安全组(Security Group)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安全组是&lt;code class=&quot;highlighter-rouge&quot;&gt;实例级别&lt;/code&gt;的访问控制规则,可绑定到具体实例。&lt;/p&gt;

&lt;p&gt;一个安全组的定义包含以下几个部分:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;名称、所属的VPC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/aws-sg-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进站(inbound)规则&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/aws-sg-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;出站(outbound)规则&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/aws-sg-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网络访问列表(Network access control lists)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nacl是subnet级别的网络访问控制规则，可绑定的子网。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vpc-0-sg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aws的vpc是amazon云环境实现的一套Network Infrastructure。目标是实现网络层结构的自由编排。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="automation" />
      

      
        <summary type="html">计费规则</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[GCE]单节点部署kubernetes集群</title>
      <link href="http://localhost:4000/k8s-from-scrach" rel="alternate" type="text/html" title="[GCE]单节点部署kubernetes集群" />
      <published>2018-10-10T19:20:11+08:00</published>
      <updated>2018-10-10T19:20:11+08:00</updated>
      <id>http://localhost:4000/k8s-from-scrach</id>
      <content type="html" xml:base="http://localhost:4000/k8s-from-scrach">&lt;p&gt;使用kubeadm部署单master节点的k8s, 1个master + 2个minion&lt;/p&gt;

&lt;h3 id=&quot;1-安装docker以及master节点初始化&quot;&gt;1. 安装Docker以及Master节点初始化&lt;/h3&gt;

&lt;p&gt;安装docker&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt install docker.io

sudo systemctl enable docker

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装kubeadm&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update \
  &amp;amp;&amp;amp; sudo apt-get install -y apt-transport-https \
  &amp;amp;&amp;amp; curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -

# k8s的资源暂不可用,使用16.04的更新资源 (xenial)
echo &quot;deb http://apt.kubernetes.io/ kubernetes-xenial main&quot; \
  | sudo tee -a /etc/apt/sources.list.d/kubernetes.list \
  &amp;amp;&amp;amp; sudo apt-get update

sudo apt install -y kubeadm  kubelet kubernetes-cni

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关闭交换分区&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo swapoff -a 
sudo rm -f /swapfile
sudo vi /etc/fstab   # 注释点 /swapfile 入口

sudo swapon --summary # 确认，如果没有输出，表明已经关闭
cat /proc/swaps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;关闭交换分区的原因，官方的说法是为了性能，设计者希望每个kubelet都可以实时响应&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/53533&quot;&gt;Kubelet/Kubernetes should work with Swap Enabled&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-初始化master节点&quot;&gt;2. 初始化master节点&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IP_ADDR=$(ip addr show eno1 | grep -Po 'inet \K[\d.]+')
echo $IP_ADDR

sudo kubeadm init --pod-network-cidr=192.168.0.0/16 --apiserver-advertise-address=${IP_ADDR} --kubernetes-version stable-1.2.1

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;cidr是一个很重要的概念，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1&quot;&gt;推荐阅读&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CIDR分配的网络资源是网段，而不是具体的地址。所以在AWS或常见云平台上申请网络资源时，先输入CIDR，比如10.1.0.0/16。16对应的子网掩码是255.255.0.0。&lt;/p&gt;

&lt;p&gt;默认的情况下，单个master节点是无法正常工作的，它不会分配pods资源。这里有个命令可以使master工作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl taint nodes --all node-role.kubernetes.io/master-
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;master节点被加入到了资源调度里面去。&lt;/p&gt;

&lt;h3 id=&quot;3-安装pod-network插件&quot;&gt;3. 安装Pod Network插件&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The network must be deployed before any applications. Also, CoreDNS will not start up before a network is installed. kubeadm only supports Container Network Interface (CNI) based networks (and does not support kubenet).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;网络组件有很多种，Flannel， Weave Net,Calico 等&lt;/p&gt;

&lt;p&gt;这里选择calico&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml
kubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果确认
kubectl get pods –all-namespaces&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;coredns在网络组建没有安装或者没有初始化完毕前是pending的状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-加入minion节点&quot;&gt;4. 加入Minion节点&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubeadm join 192.168.12.39:6443 --token 9uqyzo.y773su1b99kolayf --discovery-token-ca-cert-hash sha256:10ca82d1b6e3d9402b5243fa360e9c11a05320c1bd39989ab24aea1fcd6f8629
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段命令是kubeadm init以后给出的。&lt;/p&gt;

&lt;p&gt;–token 是节点加入凭证，如果忘记了，在master节点上可以重新获取&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubeadm token list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;顺利的话， join命令在几秒内就完成了。&lt;/p&gt;

&lt;p&gt;加入节点确认&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get nodes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5-遇到的问题&quot;&gt;5. 遇到的问题&lt;/h3&gt;

&lt;p&gt;在ubuntu18.04的版本里，默认CNI插件不兼容k8s 1.12,需要重新编译, 插件地址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/containernetworking/plugins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参考&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://k8smeetup.github.io/docs/admin/kubeadm/&quot;&gt;kubeadm 设置工具参考指南&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_34463875/article/details/78042852&quot;&gt;Kubenetes中的证书&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1s&quot;&gt;无类别域间路由&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/&quot;&gt;Creating a single master cluster with kubeadm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.projectcalico.org/v3.2/getting-started/kubernetes/&quot;&gt;Quickstart for Calico on Kubernetes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;k8s 至今仍是实现不管是monolithic还是微服务架构最理想的容器编排手段。优点是概念相对来说比较少，入门容易。缺点是每个概念彻底理解清楚非常难，因为每个resource之间的嵌套引用。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="automation" />
      

      
        <summary type="html">使用kubeadm部署单master节点的k8s, 1个master + 2个minion</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Essential系列-ceph对象存储/日志文件系统是如何工作的(二)</title>
      <link href="http://localhost:4000/archi-ceph-osd-essentials-02" rel="alternate" type="text/html" title="Essential系列-ceph对象存储/日志文件系统是如何工作的(二)" />
      <published>2018-02-26T21:00:10+08:00</published>
      <updated>2018-02-26T21:00:10+08:00</updated>
      <id>http://localhost:4000/archi-ceph-osd-essentials-02</id>
      <content type="html" xml:base="http://localhost:4000/archi-ceph-osd-essentials-02">&lt;p&gt;How to build storage infrastruction?&lt;/p&gt;

&lt;p&gt;基于unix文件系统是操作系统中&lt;code class=&quot;highlighter-rouge&quot;&gt;简单易懂&lt;/code&gt;的部分。&lt;/p&gt;

&lt;p&gt;这是由它的设计决定的-一切皆是文件。&lt;/p&gt;

&lt;p&gt;当前的文件系统基本分为两类:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;基于事务或日志(journal)的写方式，它提供了更好的高可用性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不含日志的写方式&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;不使用日志no-journal的文件系统-ext2的工作方式&quot;&gt;不使用日志(no journal)的文件系统 ext2的工作方式&lt;/h5&gt;

&lt;p&gt;文件系统中的存储概念&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;block&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个逻辑块(block)是最小的能被文件系统分配的存储单元，以用字节(byte)为单位。单个文件可以包含多个blocks&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;逻辑卷(local volume)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个磁盘分区或者整个物理磁盘&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;inode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文件元数据(meta data)的存储数据结构。&lt;/p&gt;

&lt;p&gt;文件数据本身以外的数据,比如 时间戳、ownership 信息，访问权限，安全信息，文件大小以及存储的位置。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;directory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目录，一种特别的文件，包含内容文件的inode元数据列表。&lt;/p&gt;

&lt;p&gt;基本面上看，文件系统的写文件过程至少包含了2个IO过程:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;inode(文件元数据)的写入过程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实际文件内容写入对应的block的过程&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里面存在2个问题:&lt;/p&gt;

&lt;p&gt;先写元数据还是先写实际数据?&lt;/p&gt;

&lt;p&gt;如果在任意一个IO中，出现了异常中断应该如何处理?&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;这两个问题是所有多重IO系统面临的通用问题&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;journaling&quot;&gt;Journaling&lt;/h5&gt;

&lt;p&gt;在linux系统中，一个文件的元信息有inode结构维持。&lt;/p&gt;

&lt;p&gt;inode的主要结构信息:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;owner : ****owner username****
permissions : read-write
size : 1
pointer : 4 # 指向block
pointer : null
pointer : null
pointer : null
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一次IO要经过三次IO操作:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/inode01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Bitmap 结构描述了inode和block的对应关系&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;inode结构描述block的具体信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;block存储数据本身的二进制内容&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上三次独立的IO过程，任意一个阶段出现异常，都会引起数据的丢失或者不一致的情况:&lt;/p&gt;

&lt;p&gt;1) Block 被写入磁盘，但是Inode信息没有写入或者更新&lt;/p&gt;

&lt;p&gt;2) inode被更新了，但是block没有写完整&lt;/p&gt;

&lt;p&gt;3) bitmap更新了，但是剩余两个信息不完整&lt;/p&gt;

&lt;p&gt;以上三个问题归结为&lt;code class=&quot;highlighter-rouge&quot;&gt;IO一致性&lt;/code&gt;问题&lt;/p&gt;

&lt;p&gt;目前有以下几种解决方式:&lt;/p&gt;

&lt;p&gt;一、使用文件系统扫描工具 fsck&lt;/p&gt;

&lt;p&gt;这是一种亡羊补牢的方式。&lt;/p&gt;

&lt;p&gt;File system checker(文件系统扫描)&lt;/p&gt;

&lt;p&gt;unix系统中典型的文件扫描工具是fsck(注: 在linux系统启动过程中，如果之前异常关机，会启动这个扫面程序)&lt;/p&gt;

&lt;p&gt;fsck的确认项动作:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;superblock 超级块检查&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;free blocks 检查已分配的区块和inode以及bitmap的对应关系，如果出现异常，重建元数据信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;inode 完整新检查 &amp;amp;&amp;amp; inode重复检查&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;目录检查&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;坏块检查&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;二、使用日志journaling&lt;/p&gt;

&lt;p&gt;日志文件系统使用的常规手段是 Wal， 很面熟的词，因为这是数据库系统输入写入和实现日志分发功能的常用手段，全称是write-ahead loging。&lt;/p&gt;

&lt;p&gt;wal的思想是:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;实际执行写入动作之前，做一个动作笔记或者action list 并存在一个地方。这一步操作成为写前日志。postgresql的默认存贮位置是DATA/wal&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这一步动作的目的是先记录动作的所有raw data，如果在接下来的动作中，任意一步失败了，可以通过回放解决。这也是很多事务型的操作常用的设计手段。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ext3是经典的、常用的基于journaling文件系统。&lt;/p&gt;

&lt;p&gt;ext4实现完整的、&lt;code class=&quot;highlighter-rouge&quot;&gt;state safe&lt;/code&gt; 状态安全的日志原子性写入操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ext4journaling01s.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上，可归结为三个步骤:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Action 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Journal write transaction 开启一个日志写入事务&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Action 2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Journal commit, 日志内的内容写入完成以后，提交事务。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Action 3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Checkpoint, 这一步讲更新的内容写入磁盘上的最终的位置，包括数据本身和元数据。&lt;/p&gt;

&lt;p&gt;这样，日志文件以一个事务的数据结构大小为窗口，向前推进，如果在数据写入磁盘的过程中出现异常，仅仅replay这个事务即可。&lt;/p&gt;

&lt;p&gt;这里的问题是，随着文件写入越来越多，日志文件会越来越大，如何处理这种问题?&lt;/p&gt;

&lt;p&gt;答案是 使用循环日志&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/journalex403.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Action 4&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回收已经写入成功的事务占用的磁盘空间。&lt;/p&gt;

&lt;p&gt;总结，这种写入方式确实实现了状态安全的写入过程，但是问题是，数据写入了2次。&lt;/p&gt;

&lt;p&gt;更优化、最常用的方式是，在事务提交中，不写入数据本身，仅仅写入数据的meta data。&lt;/p&gt;

&lt;p&gt;NTFS, XFS, EXT3 都实现了这种方式。&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;基于日志journal的文件写入方式，也用在mysql和postgresql数据持久化过程之中。是一种通用思想。
ceph的架构目标是实现存储Infrastruction， 它在journing之上又构建了一层meta data，目标是实现存储的任务水平扩展，同时保证原子性。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="automation" />
      

      
        <summary type="html">How to build storage infrastruction?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Essential系列-存储技术概述(一)</title>
      <link href="http://localhost:4000/archi-ceph-osd-essentials" rel="alternate" type="text/html" title="Essential系列-存储技术概述(一)" />
      <published>2018-02-26T21:00:10+08:00</published>
      <updated>2018-02-26T21:00:10+08:00</updated>
      <id>http://localhost:4000/archi-ceph-osd-essentials</id>
      <content type="html" xml:base="http://localhost:4000/archi-ceph-osd-essentials">&lt;p&gt;存储技术分类&lt;/p&gt;

&lt;h4 id=&quot;云环境中的存储技术&quot;&gt;云环境中的存储技术&lt;/h4&gt;

&lt;h5 id=&quot;block-storage&quot;&gt;Block Storage&lt;/h5&gt;

&lt;p&gt;传统的块存储的例子是物理磁盘，它就是一个块存储设备。&lt;/p&gt;

&lt;p&gt;但云环境中的Block Storage是通过Nas(Network Attached Storage)模拟的块设备(不然的话，如何做到实时分配和计费?)。&lt;a href=&quot;https://en.wikipedia.org/wiki/Block-level_storage&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不管传统意义上的块存储(磁盘)，还是云环境中的块存储，它的主要目的只有一个:&lt;/p&gt;

&lt;p&gt;为性能敏感的数据提供廉价的持久化的存储。&lt;/p&gt;

&lt;p&gt;它的特性是:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;低延迟&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;传输速度块(相对网络存储)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持多种操作系统，提供硬件级容错机制&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据在块上是如何组织的?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blockstorage01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;数据被存储在固定大小的块上(比如 512字节)，块是最基础的存储单元。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;没有比块更高的元数据(meta data)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果操作系统要访问块数据，它需要先用某种格式(ext2,3,4)挂载(mount)。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这就是在linux系统上无法直接访问fat格式的磁盘的原因。&lt;/p&gt;

&lt;p&gt;由操作系统决定块内的数据如何被访问(提供访问操作视图)。&lt;/p&gt;

&lt;p&gt;数据块接口的性能比较&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blockstorage02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(光纤网络的速度可达到100G/S)&lt;/p&gt;

&lt;p&gt;云环境中常见块存储服务:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;EBS(AWS Elastic Block Storage), AWS提供的原始数据存储服务,格式化以后它可以被挂载到EC2示例中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Azure Block Storage，微软Azure云提供的块存储服务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Google Persistence Disks，谷歌的持久化存储服务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;阿里云的云盘/本地盘&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;file-storage&quot;&gt;File Storage&lt;/h5&gt;

&lt;p&gt;文件存储，相对于块存储，它的操作视图是基于文件或者文档。相对于块高了一个层次。&lt;/p&gt;

&lt;p&gt;文件的典型特性:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;所有文件都有一个名字，并且是可字节寻址的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可随机访问。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过文件句柄可以进行IO操作。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/filestorage01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用场景:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;文档共享&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库集群&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;大数据存储&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文档存储最简单的例子是Samba和NFS&lt;/p&gt;

&lt;h5 id=&quot;object-storage&quot;&gt;Object Storage&lt;/h5&gt;

&lt;p&gt;对象存储是云环境中，被应用常用的一种存储方式。&lt;/p&gt;

&lt;p&gt;数据存储的特性:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;包含一个句柄URL格式或者ObjectId&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有元数据，包括用户元数据和操作系统元数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;包含版本&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不需要挂载&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可随处访问(at any endpoint)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;常见用途:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;归档存储&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Server-less 容器存储&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同步或共享文件&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;块存储是构建在inode、block、volume逐层索引原理之上的存储方式。
文件存储是以文件操作(POSIX接口)为操作视图实现的存储方式。
对象存储为适应云环境碎片文件存储诞生的，在文件存储至少扩展了元信息，增加了环境上下文、云用户信息。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="automation" />
      

      
        <summary type="html">存储技术分类</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Devops那些事-虚拟化讲座讲义</title>
      <link href="http://localhost:4000/devops-docker-presentation" rel="alternate" type="text/html" title="Devops那些事-虚拟化讲座讲义" />
      <published>2017-11-22T10:01:19+08:00</published>
      <updated>2017-11-22T10:01:19+08:00</updated>
      <id>http://localhost:4000/devops-docker-presentation</id>
      <content type="html" xml:base="http://localhost:4000/devops-docker-presentation">&lt;p&gt;docker基础讲座讲义&lt;/p&gt;

&lt;h4 id=&quot;讲座内容&quot;&gt;讲座内容&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/01.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/03.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/04.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/05.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/06.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/07.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/08.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/09.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/10.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/11.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/12.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/13.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/14.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="automation" />
      

      
        <summary type="html">docker基础讲座讲义</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PostgreSQL MySQL 数据类型映射</title>
      <link href="http://localhost:4000/archi-postgresql-02" rel="alternate" type="text/html" title="PostgreSQL MySQL 数据类型映射" />
      <published>2017-08-15T18:31:11+08:00</published>
      <updated>2017-08-15T18:31:11+08:00</updated>
      <id>http://localhost:4000/archi-postgresql-02</id>
      <content type="html" xml:base="http://localhost:4000/archi-postgresql-02">&lt;p&gt;参考
&lt;a href=&quot;https://dev.mysql.com/doc/workbench/en/wb-migration-database-postgresql-typemapping.html&quot;&gt;PostgreSQL Type Mapping&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;postgresql类型-转换为-mysql类型&quot;&gt;PostgreSQL类型 转换为 MySQL类型&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;PostgreSQL Type&lt;/th&gt;
      &lt;th&gt;MySQL Type&lt;/th&gt;
      &lt;th&gt;Comment&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;INT&lt;/td&gt;
      &lt;td&gt;INT&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SMALLINT&lt;/td&gt;
      &lt;td&gt;SMALLINT&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BIGINT&lt;/td&gt;
      &lt;td&gt;BIGINT&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SERIAL&lt;/td&gt;
      &lt;td&gt;INT&lt;/td&gt;
      &lt;td&gt;Sets AUTO_INCREMENT in its table definition.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SMALLSERIAL&lt;/td&gt;
      &lt;td&gt;SMALLINT&lt;/td&gt;
      &lt;td&gt;Sets AUTO_INCREMENT in its table definition.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BIGSERIAL&lt;/td&gt;
      &lt;td&gt;BIGINT&lt;/td&gt;
      &lt;td&gt;Sets AUTO_INCREMENT in its table definition.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BIT&lt;/td&gt;
      &lt;td&gt;BIT&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BOOLEAN&lt;/td&gt;
      &lt;td&gt;TINYINT(1)&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;REAL&lt;/td&gt;
      &lt;td&gt;FLOAT&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DOUBLE PRECISION&lt;/td&gt;
      &lt;td&gt;DOUBLE&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NUMERIC&lt;/td&gt;
      &lt;td&gt;DECIMAL&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DECIMAL&lt;/td&gt;
      &lt;td&gt;DECIMAL&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MONEY&lt;/td&gt;
      &lt;td&gt;DECIMAL(19,2)&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CHAR&lt;/td&gt;
      &lt;td&gt;CHAR/LONGTEXT&lt;/td&gt;
      &lt;td&gt;Depending on its length. MySQL Server 5.5 and above can have CHAR columns with a length up to 255 characters. Anything larger is migrated as LONGTEXT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NATIONAL CHARACTER&lt;/td&gt;
      &lt;td&gt;CHAR/LONGTEXT&lt;/td&gt;
      &lt;td&gt;Depending on its length. MySQL Server 5.5 and above can have VARCHAR columns with a length up to 65535 characters. Anything larger is migrated to one of the TEXT blob types. In MySQL, character set of strings depend on the column character set instead of the datatype.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VARCHAR&lt;/td&gt;
      &lt;td&gt;VARCHAR/MEDIUMTEXT/LONGTEXT&lt;/td&gt;
      &lt;td&gt;Depending on its length. MySQL Server 5.5 and above can have VARCHAR columns with a length up to 65535 characters. Anything larger is migrated to one of the TEXT blob types.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NATIONAL CHARACTER VARYING&lt;/td&gt;
      &lt;td&gt;VARCHAR/MEDIUMTEXT/LONGTEXT&lt;/td&gt;
      &lt;td&gt;Depending on its length. MySQL Server 5.5 and above can have VARCHAR columns with a length up to 65535 characters. Anything larger is migrated to one of the TEXT blob types. In MySQL, character set of strings depend on the column character set instead of the datatype.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATE&lt;/td&gt;
      &lt;td&gt;DATE&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TIME&lt;/td&gt;
      &lt;td&gt;TIME&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TIMESTAMP&lt;/td&gt;
      &lt;td&gt;DATETIME&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;INTERVAL&lt;/td&gt;
      &lt;td&gt;TIME&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BYTEA&lt;/td&gt;
      &lt;td&gt;LONGBLOB&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TEXT&lt;/td&gt;
      &lt;td&gt;LONGTEXT&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CIDR&lt;/td&gt;
      &lt;td&gt;VARCHAR(43)&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;INET&lt;/td&gt;
      &lt;td&gt;VARCHAR(43)&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MACADDR&lt;/td&gt;
      &lt;td&gt;VARCHAR(17)&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UUID&lt;/td&gt;
      &lt;td&gt;VARCHAR(36)&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;XML&lt;/td&gt;
      &lt;td&gt;LONGTEXT&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;JSON&lt;/td&gt;
      &lt;td&gt;LONGTEXT&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TSVECTOR&lt;/td&gt;
      &lt;td&gt;LONGTEXT&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TSQUERY&lt;/td&gt;
      &lt;td&gt;LONGTEXT&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ARRAY&lt;/td&gt;
      &lt;td&gt;LONGTEXT&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POINT&lt;/td&gt;
      &lt;td&gt;POINT&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LINE&lt;/td&gt;
      &lt;td&gt;LINESTRING&lt;/td&gt;
      &lt;td&gt;Although LINE length is infinite, and LINESTRING is finite in MySQL, it is approximated&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LSEG&lt;/td&gt;
      &lt;td&gt;LINESTRING&lt;/td&gt;
      &lt;td&gt;A LSEG is like a LINESTRING with only two points&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BOX&lt;/td&gt;
      &lt;td&gt;POLYGON&lt;/td&gt;
      &lt;td&gt;A BOX is a POLYGON with five points and right angles&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PATH&lt;/td&gt;
      &lt;td&gt;LINESTRING&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POLYGON&lt;/td&gt;
      &lt;td&gt;POLYGON&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CIRCLE&lt;/td&gt;
      &lt;td&gt;POLYGON&lt;/td&gt;
      &lt;td&gt;A POLYGON is used to approximate a CIRCLE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TXID_SNAPSHOT&lt;/td&gt;
      &lt;td&gt;VARCHAR&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;类型&quot;&gt;类型&lt;/h3&gt;
&lt;p&gt;1. 数据类型&lt;/p&gt;

&lt;p&gt;1.1 PostgreSQL&lt;/p&gt;

&lt;p&gt;高精度numeric, 浮点, 自增序列，货币，字节流，时间，日期，时间戳，布尔，枚举，平面几何，立体几何，多维几何，地球，PostGIS，网络，比特流，全文检索，UUID，XML，JSON，数组，复合类型，域类型，范围，树类型，化学类型，基因序列，FDW, 大对象, 图像&lt;/p&gt;

&lt;p&gt;1.2 MySQL&lt;/p&gt;

&lt;p&gt;数字，时间，字符串，简单的GIS，JSON&lt;/p&gt;

&lt;p&gt;2. 支持索引的数据类型&lt;/p&gt;

&lt;p&gt;2.1 PostgreSQL&lt;/p&gt;

&lt;p&gt;高精度numeric, 浮点, 自增序列，货币，字节流，时间，日期，时间戳，布尔，枚举，平面几何，立体几何，多维几何，地球，PostGIS，网络，比特流，全文检索，UUID，XML，JSON，数组，复合类型，域类型，范围，树类型，化学，基因序列&lt;/p&gt;

&lt;p&gt;2.2 MySQL&lt;/p&gt;

&lt;p&gt;数字，字符串，比特流，时间，全文检索，GIS&lt;/p&gt;

&lt;h3 id=&quot;索引支持&quot;&gt;索引支持&lt;/h3&gt;
&lt;p&gt;1. 索引方法&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持 btree, hash, gist, sp-gist, gin, brin , bloom , rum 索引&lt;/p&gt;

&lt;p&gt;MySQL 支持 btree, gis类型索引&lt;/p&gt;

&lt;p&gt;2. 规则表达式、前后模糊查询，支持索引检索&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;3. 数组支持索引&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;4. 全文检索支持索引&lt;/p&gt;

&lt;p&gt;5. 索引扩展功能&lt;/p&gt;

&lt;p&gt;5.1 PostgreSQL 支持 表达式索引，部分索引，联合索引&lt;/p&gt;

&lt;p&gt;5.2 PostgreSQL 支持图像相似度、文本相似度搜索&lt;/p&gt;

&lt;p&gt;5.3 自定义索引访问方法(bloom, rum, ……)&lt;/p&gt;

&lt;p&gt;PostgreSQL支持&lt;/p&gt;

&lt;h3 id=&quot;多引擎和外部源支持&quot;&gt;多引擎和外部源支持&lt;/h3&gt;
&lt;p&gt;1. 多引擎支持&lt;/p&gt;

&lt;p&gt;1.1 PostgreSQL&lt;/p&gt;

&lt;p&gt;内置heap, 通过插件实现内存表, 列存储, 压缩存储, 流式存储, 非关系存储等。&lt;/p&gt;

&lt;p&gt;1.2 MySQL&lt;/p&gt;

&lt;p&gt;MyISAM, innodb, …&lt;/p&gt;

&lt;p&gt;2. 外部表&lt;/p&gt;

&lt;p&gt;PostgreSQL支持任意外部数据源, (例如jdbc, file, odbc, oracle, mysql, db2, redis, mongo, ES, hadoop……)&lt;/p&gt;

&lt;p&gt;https://wiki.postgresql.org/wiki/Fdw&lt;/p&gt;

&lt;p&gt;3. dblink&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;4. 内存表&lt;/p&gt;

&lt;p&gt;PostgreSQL 通过外部表支持，或者通过插件支持&lt;/p&gt;

&lt;p&gt;5. ES(弹性搜索引擎) 引擎&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;h3 id=&quot;安全&quot;&gt;安全&lt;/h3&gt;
&lt;p&gt;1. 数据加密&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持加密数据类型，可选GPG加密算法&lt;/p&gt;

&lt;p&gt;2. 认证方法&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持 密码、LDAP、AD、GSSAPI、SSPI、Ident、Peer、RADIUS、PAM、签名认证&lt;/p&gt;

&lt;p&gt;3. 数据传输加密&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;4. 行安全策略&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;5. 数据库内部支持libselinux接口, (美国国家安全局制定的安全加强标准)&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;h3 id=&quot;优化器&quot;&gt;优化器&lt;/h3&gt;
&lt;p&gt;http://www.postgresql.org/docs/9.5/static/runtime-config-query.html&lt;/p&gt;

&lt;p&gt;1. GPU 并行计算支持&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;2. 遗传优化器算法&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持CBO、CRO、遗传算法&lt;/p&gt;

&lt;p&gt;3. HINT PLAN&lt;/p&gt;

&lt;p&gt;4. CPU 并行计算&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持 (线性性能提升)&lt;/p&gt;

&lt;p&gt;5. 自定义成本因子&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;h3 id=&quot;编程扩展&quot;&gt;编程扩展&lt;/h3&gt;
&lt;p&gt;1. 是否支持采样查询&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;2. 是否支持扩展采样算法&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;3. 自定义数据类型&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;4. 自定义索引方法&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;5. 字符集自动转换, C扩展接口&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;6. 自定义聚合&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;7. 自定义窗口&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;h3 id=&quot;扩展能力&quot;&gt;扩展能力&lt;/h3&gt;
&lt;p&gt;1. 类型扩展，操作符扩展，函数扩展，索引方法扩展，索引扩展，&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;2. C触发器函数， C事件触发器函数&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;3. 函数语言扩展&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持扩展函数支持接口, erlang, ….&lt;/p&gt;

&lt;p&gt;4. 机器学习库&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;

&lt;p&gt;5. 流式计算&lt;/p&gt;

&lt;p&gt;PostgreSQL 支持&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="automation" />
      

      
        <summary type="html">参考 PostgreSQL Type Mapping</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Postgres的流复制最佳实践</title>
      <link href="http://localhost:4000/archi-postgresql-01" rel="alternate" type="text/html" title="Postgres的流复制最佳实践" />
      <published>2017-08-11T19:30:10+08:00</published>
      <updated>2017-08-11T19:30:10+08:00</updated>
      <id>http://localhost:4000/archi-postgresql-01</id>
      <content type="html" xml:base="http://localhost:4000/archi-postgresql-01">&lt;p&gt;一主两从，介绍PG 9.5的主从最佳实践。&lt;/p&gt;

&lt;h3 id=&quot;初始化主库&quot;&gt;初始化主库&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;initdb -D /exp2/pgdata -E UTF8 --locale=C -U postgres 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;配置postgresqlconf&quot;&gt;配置postgresql.conf&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;listen_addresses = '*'			
port = 5433				
max_connections = 700			
unix_socket_directories = '/exp2/pgdata/data_salon/socket'	
shared_buffers = 1024MB			
work_mem = 10MB				
dynamic_shared_memory_type = posix	
wal_level = hot_standby			
wal_buffers = 1024kB			
checkpoint_segments = 64		
max_wal_senders = 3		
wal_keep_segments = 32		
random_page_cost = 2.0			
effective_cache_size = 3072MB
logging_collector = on			
log_directory = 'pg_log'		
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'	
log_rotation_age = 1d			
log_rotation_size = 20MB		
log_min_duration_statement = 5000	
log_line_prefix = '[%d %p %t %c %l]'	
log_timezone = 'Japan'
autovacuum_vacuum_cost_limit = 200	
datestyle = 'iso, ymd'
timezone = 'Japan'
client_encoding = UTF8						
default_text_search_config = 'pg_catalog.simple'
deadlock_timeout = 100s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;配置pg_hbaconf&quot;&gt;配置pg_hba.conf&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# &quot;local&quot; is for Unix domain socket connections only  
local   all             all                                     trust  
# IPv4 local connections:  
host    all             all             127.0.0.1/32            trust  
# IPv6 local connections:  
host    all             all             ::1/128                 trust  
# Allow replication connections from localhost, by a user with the  
# replication privilege.  
local   replication     all                                     trust  
host    replication     all             127.0.0.1/32            trust  
host    replication     all             ::1/128                 trust  
host replication all 0.0.0.0/0 md5  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;配置recoverydone&quot;&gt;配置recovery.done&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi recovery.done  
  
recovery_target_timeline = 'latest'  
standby_mode = on  
primary_conninfo = 'host=127.0.0.1 port=5433 user=app_user password=app123'  
# recovery_min_apply_delay = 0   #延迟多少分钟应用，用户可以配置延迟的备库，例如给一点误操作的缓冲时间。在备库不会这么早被应用。  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;启动主库&quot;&gt;启动主库&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pg_ctl start -D /exp2/pgdata&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;创建流复制角色&quot;&gt;创建流复制角色&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;psql 
Type &quot;help&quot; for help.  
  
postgres=# set synchronous_commit =off;  
SET  
postgres=# create role rep login replication encrypted password 'pwd';  
CREATE ROLE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;创建备库&quot;&gt;创建备库&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pg_basebackup -D /exp2/pgdata -F p -X stream -h 127.0.0.1 -p 5433 -U rep  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;启动备库&quot;&gt;启动备库&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mv recovery.done recovery.conf  
pg_ctl start -D /exp2/pgdata
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;压测&quot;&gt;压测&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pgbench -i -s 100 -h 127.0.0.1 -p 5433 -U postgres  
  
pgbench -n -r -P 1 -h 127.0.0.1 -p 5433 -U postgres -c 32 -j 32 -T 120  

transaction type: &amp;lt;builtin: TPC-B (sort of)&amp;gt;
scaling factor: 100
query mode: simple
number of clients: 32
number of threads: 32
duration: 120 s
number of transactions actually processed: 1326066
latency average = 2.896 ms
latency stddev = 2.030 ms
tps = 11050.199659 (including connections establishing)
tps = 11051.140876 (excluding connections establishing)
script statistics:
 - statement latencies in milliseconds:
         0.002  \set aid random(1, 100000 * :scale)
         0.001  \set bid random(1, 1 * :scale)
         0.001  \set tid random(1, 10 * :scale)
         0.000  \set delta random(-5000, 5000)
         0.043  BEGIN;
         0.154  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
         0.112  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
         0.159  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
         0.423  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
         0.092  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
         1.910  END;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="automation" />
      

      
        <summary type="html">一主两从，介绍PG 9.5的主从最佳实践。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">azure云基础架构(infrastructure)</title>
      <link href="http://localhost:4000/archi-azure-architecture-design" rel="alternate" type="text/html" title="azure云基础架构(infrastructure)" />
      <published>2017-07-31T20:12:19+08:00</published>
      <updated>2017-07-31T20:12:19+08:00</updated>
      <id>http://localhost:4000/archi-azure-architecture-design</id>
      <content type="html" xml:base="http://localhost:4000/archi-azure-architecture-design">&lt;p&gt;公有云架构设计以及设计技巧&lt;/p&gt;

&lt;h3 id=&quot;一-资源选型策略&quot;&gt;(一) 资源选型策略&lt;/h3&gt;

&lt;h4 id=&quot;架构设计时充分利用云上基础设施&quot;&gt;架构设计时充分利用云上基础设施。&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;azure提供了第7层(http)的application gateway, 它可以负责负载的分发，并可以通过sesssion affinity实现session的绑定。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这时候在设计infra的时候，可以考虑这一点避免重复设计session的共享机制。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;灾备。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;azure在设计的时候，存储已经考虑了跨大区的灾备。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Monitoring &amp;amp;&amp;amp; Health checking &amp;amp;&amp;amp; Alert&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Logging&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上工具不都是免费的，但是性价比比较高。&lt;/p&gt;

&lt;h4 id=&quot;了解azure云的资费方式&quot;&gt;了解azure云的资费方式&lt;/h4&gt;

&lt;p&gt;国外(GCE, Aws)的计算资源都是按照per-hour收费的。所以在设计时，哪些是长期运行的几点，哪些是临时的job，需要分清楚。&lt;/p&gt;

&lt;p&gt;azure提供了一个非常难用的&lt;a href=&quot;https://azure.microsoft.com/en-us/pricing/calculator/&quot;&gt;价格计算器&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果不是流量巨大的应用或者流量突发类型的应用， 设计指导方针是 先按照架构设计&lt;code class=&quot;highlighter-rouge&quot;&gt;跑一次&lt;/code&gt;试试看。&lt;/p&gt;

&lt;p&gt;为什么？&lt;/p&gt;

&lt;p&gt;azure的计算资源类型从A0-G5, 有50种以上的计算资源。&lt;/p&gt;

&lt;p&gt;虽然每种类型有自己的计算能力(2 cores, 8G RAM), 也有对应的文档描述， 但是通过文档&lt;code class=&quot;highlighter-rouge&quot;&gt;很难区分&lt;/code&gt;具体型号的明确&lt;code class=&quot;highlighter-rouge&quot;&gt;界限&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;当选择的计算资源不适合时，可以实时热扩。 不用影响正在运行的进程。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;azure上的gateway，包括loadbalencer 后端是通过windows上的IIS实现的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们曾经发生一个事故。
曾经有一个项目部署了一套saas系统到azure上，当压力增加时(qps大约200左右) 会引发502 error。&lt;/p&gt;

&lt;p&gt;投诉路线是这样的&lt;/p&gt;

&lt;p&gt;中国上海 $→$  亚洲日本 $→$ 美国总部。&lt;/p&gt;

&lt;p&gt;最终问题定位在application gateway上，升级以后问题才解决。&lt;/p&gt;

&lt;h3 id=&quot;二-azure上的系统架构设计样例&quot;&gt;(二) azure上的系统架构设计样例&lt;/h3&gt;

&lt;p&gt;开始设计之前，请参考一下这个lib。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://azure.microsoft.com/en-us/solutions/architecture/cross-cloud-scaling/&quot;&gt;https://azure.microsoft.com/en-us/solutions/architecture/cross-cloud-scaling/&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="automation" />
      

      
        <summary type="html">公有云架构设计以及设计技巧</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">aws中配置elastic beantalk的ssl证书</title>
      <link href="http://localhost:4000/devops-aws-ssl-csr" rel="alternate" type="text/html" title="aws中配置elastic beantalk的ssl证书" />
      <published>2017-06-20T10:16:10+08:00</published>
      <updated>2017-06-20T10:16:10+08:00</updated>
      <id>http://localhost:4000/devops-aws-ssl-csr</id>
      <content type="html" xml:base="http://localhost:4000/devops-aws-ssl-csr">&lt;p&gt;配置elastic beantalk的ssl证书&lt;/p&gt;

&lt;h3 id=&quot;生成私钥&quot;&gt;生成私钥&lt;/h3&gt;

&lt;h4 id=&quot;安装opensslmac-osx&quot;&gt;安装openssl(mac osx)&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装&lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL工具&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行命令&lt;code class=&quot;highlighter-rouge&quot;&gt;openssl req -new -nodes -sha256 -newkey rsa:2048 -keyout myprivate.key -out mydomain.csr&lt;/code&gt;生成CSR文件。其中，&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-new&lt;/code&gt; 指定生成一个新的CSR。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-nodes&lt;/code&gt; 指定私钥文件不被加密。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-sha256&lt;/code&gt; 指定摘要算法。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-keyout&lt;/code&gt; 生成私钥文件。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-newkey rsa:2048&lt;/code&gt; 指定私钥类型和长度。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;您手动生成CSR文件时，一般需要输入以下信息：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 输入的中文信息需要使用UTF8编码格式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Organization Name(O)： 申请单位名称法定名称，可以是中文或英文。&lt;/li&gt;
  &lt;li&gt;Organization Unit(OU)： 申请单位的所在部门，可以是中文或英文。&lt;/li&gt;
  &lt;li&gt;Country Code(C)： 申请单位所属国家，只能是两个字母的国家码。例如，中国只能是CN。&lt;/li&gt;
  &lt;li&gt;State or Province(S)： 申请单位所在省名或州名，可以是中文或英文。&lt;/li&gt;
  &lt;li&gt;Locality(L)： 申请单位所在城市名，可以是中文或英文。&lt;/li&gt;
  &lt;li&gt;Common Name(CN)： 申请SSL证书的具体网站域名。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;生成CSR文件mydomain.csr。&lt;/p&gt;

    &lt;p&gt;需要输入的信息说明如下：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;字段&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
          &lt;th&gt;示例&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Country Name&lt;/td&gt;
          &lt;td&gt;ISO国家代码（两位字符）&lt;/td&gt;
          &lt;td&gt;CN&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;State or Province Name&lt;/td&gt;
          &lt;td&gt;所在省份&lt;/td&gt;
          &lt;td&gt;ZheJiang&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Locality Name&lt;/td&gt;
          &lt;td&gt;所在城市&lt;/td&gt;
          &lt;td&gt;HangZhou&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Organization Name&lt;/td&gt;
          &lt;td&gt;公司名称&lt;/td&gt;
          &lt;td&gt;HangZhou xxx Technologies, Inc.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Organizational Unit Name&lt;/td&gt;
          &lt;td&gt;部门名称&lt;/td&gt;
          &lt;td&gt;IT Dept.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Common Name&lt;/td&gt;
          &lt;td&gt;申请证书的域名&lt;/td&gt;
          &lt;td&gt;www.example.com&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Email Address&lt;/td&gt;
          &lt;td&gt;不需要输入&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;A challenge password&lt;/td&gt;
          &lt;td&gt;不需要输入&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;完成命令提示的输入后，会在当前目录下生成myprivate.key（私钥文件）和 mydomain.csr（CSR，证书请求文件）两个文件。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="automation" />
      

      
        <summary type="html">配置elastic beantalk的ssl证书</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">在tls数据传输中如何验证证书有效性</title>
      <link href="http://localhost:4000/security-tls" rel="alternate" type="text/html" title="在tls数据传输中如何验证证书有效性" />
      <published>2017-05-29T17:17:19+08:00</published>
      <updated>2017-05-29T17:17:19+08:00</updated>
      <id>http://localhost:4000/security-tls</id>
      <content type="html" xml:base="http://localhost:4000/security-tls">&lt;h4 id=&quot;tls安全协议&quot;&gt;TLS安全协议&lt;/h4&gt;
&lt;p&gt;TODO&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>mikezhang</name>
        
        
      </author>

      

      
        <category term="automation" />
      

      
        <summary type="html">TLS安全协议 TODO</summary>
      

      
      
    </entry>
  
</feed>
