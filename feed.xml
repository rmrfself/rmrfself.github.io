<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-04-03T13:29:28+08:00</updated><id>http://localhost:4000/</id><title type="html">张庆华的个人日志</title><subtitle>Learn, Innovate, Share - Business Based Vision.</subtitle><entry><title type="html">实现AI的基本策略</title><link href="http://localhost:4000/data-scientist-startup" rel="alternate" type="text/html" title="实现AI的基本策略" /><published>2018-12-31T16:11:01+08:00</published><updated>2018-12-31T16:11:01+08:00</updated><id>http://localhost:4000/data-scientist-startup</id><content type="html" xml:base="http://localhost:4000/data-scientist-startup">&lt;p&gt;机器学习成功的地方在于它可以做到&lt;code class=&quot;highlighter-rouge&quot;&gt;跨领域&lt;/code&gt;应用。&lt;/p&gt;

&lt;h3 id=&quot;实现ai的基本策略&quot;&gt;实现AI的基本策略&lt;/h3&gt;

&lt;h4 id=&quot;构建ai基础设施&quot;&gt;构建AI基础设施&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;矢量化的基础计算设施
    &lt;ul&gt;
      &lt;li&gt;可扩展的计算资源&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;构建基于ai的劳动力&quot;&gt;构建基于AI的&lt;code class=&quot;highlighter-rouge&quot;&gt;劳动力&lt;/code&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;机器人&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;机器设置&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;构建基于ai的可信任工具&quot;&gt;构建基于AI的可信任工具&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;智能识别，防篡改&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;基于ai的数据建模&quot;&gt;基于AI的数据建模&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;基于大数据的数据建模&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;使用ai驱动业务策略&quot;&gt;使用AI驱动业务策略&lt;/h4&gt;

&lt;h4 id=&quot;构建基于ai的交互工具echosystem&quot;&gt;构建基于AI的交互工具(echosystem)&lt;/h4&gt;

&lt;h4 id=&quot;机器学习的任务和目标&quot;&gt;机器学习的任务和目标&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;识别数据中的模式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;预测未知数据&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;机器学习&lt;/p&gt;</content><author><name>mikezhang</name></author><category term="math" /><summary type="html">机器学习成功的地方在于它可以做到跨领域应用。</summary></entry><entry><title type="html">[GCE]安装Kubernetes Dashboard</title><link href="http://localhost:4000/k8s-dashboard-install" rel="alternate" type="text/html" title="[GCE]安装Kubernetes Dashboard" /><published>2018-10-10T19:20:11+08:00</published><updated>2018-10-10T19:20:11+08:00</updated><id>http://localhost:4000/k8s-dashboard-install</id><content type="html" xml:base="http://localhost:4000/k8s-dashboard-install">&lt;p&gt;Kubeternetes Dashboatd 安装手记&lt;/p&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;

&lt;p&gt;部署之前,确认一下yaml文件是来自master分支。&lt;/p&gt;

&lt;p&gt;下面这个链接是来自dashboard在github上的最新代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://sourcegraph.com/github.com/kubernetes/dashboard@master/-/blob/src/deploy/recommended/kubernetes-dashboard.yaml?diff=cfc62d86f67b70771dfc0798f10a891aa329b9c4&amp;amp;utm_source=chrome-extension#L11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://sourcegraph.com/github.com/kubernetes/dashboard@master/-/blob/src/deploy/recommended/kubernetes-dashboard.yaml?diff=cfc62d86f67b70771dfc0798f10a891aa329b9c4&amp;amp;utm_source=chrome-extension#L11&quot;&gt;点击查看&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文件内容分为一下几个部分&lt;/p&gt;

&lt;h3 id=&quot;dashboard-secret--serviceaccount-定义&quot;&gt;Dashboard Secret &amp;amp;&amp;amp; ServiceAccount 定义&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: v1
kind: Secret
metadata:
  labels:
    k8s-app: kubernetes-dashboard
  name: kubernetes-dashboard-certs
  namespace: kube-system
type: Opaque
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Secret 在负责的网络环境中是很重要的角色,它是k8s世界里资源流通的凭证。&lt;/p&gt;

&lt;p&gt;Secret类型的k8s资源把敏感数据比如秘钥,密码,token中从配置文件中拿了出来。&lt;/p&gt;

&lt;p&gt;如果没有secret这个类型的抽象类型, 在k8s的yaml配置文件中将到处都是关于password,token,secret 这样的字样,而且密码修改后非常不容易维护。 这就是secret这类资源的价值吧。&lt;/p&gt;

&lt;p&gt;Secret是一个Map数据类型,附加了一些行为,比如可以以volume mount的方式导入到Pods定义文件中去。&lt;/p&gt;

&lt;p&gt;Secret 存储后的类型有3种&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Opaque 类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;中文意思是&lt;不透明的&gt;,以base64格式存储。&lt;/不透明的&gt;&lt;/p&gt;

&lt;p&gt;base64是一种可逆的加密方式。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo -n 'zhangqinghua' | base64

输出 emhhbmdxaW5naHVh, 反解码很容易:

echo -n 'emhhbmdxaW5naHVh' | base64 --decode 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;kubernetes.io/dockerconfigjson 类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;K8s的核心职责之一是容器编排,最常见的场景是拉取镜像并生成对应的pods资源。&lt;/p&gt;

&lt;p&gt;在这过程中需要与私有仓库进行验权,这时候用到了这个类型的secret。&lt;/p&gt;

&lt;p&gt;Secret的用法如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: test-scret-use-methods
spec:
  containers:
  - name: test-container
    image: 192.168.1.12:5000/xxxx/test-image:latest
    imagePullPolicy: Always
  imagePullSecrets:
  - name: new-created-secret-for-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中new-created-secret-for-demo是新创建的secret。&lt;/p&gt;

&lt;p&gt;在k8s的官方文档里有创建实例,&lt;a href=&quot;https://kubernetes.io/docs/concepts/configuration/secret/&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;kubernetes.io/service-account-token 类型&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;k8snode-03@A11131221040327:~/$ kubectl get serviceaccount --all-namespaces
NAMESPACE     NAME                                 SECRETS   AGE
default       default                              1         18h
kube-public   default                              1         18h
kube-system   attachdetach-controller              1         18h
kube-system   bootstrap-signer                     1         18h

k8snode-03@A11131221040327:~/$ kubectl describe serviceaccount/default -n kube-system

Name:                default
Namespace:           kube-system
Labels:              &amp;lt;none&amp;gt;
Annotations:         &amp;lt;none&amp;gt;
Image pull secrets:  &amp;lt;none&amp;gt;
Mountable secrets:   default-token-jmgnw
Tokens:              default-token-jmgnw
Events:              &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Serviceaccount作为独立资源,关联了namespace、以及和它有关的token、secrets。&lt;/p&gt;

&lt;p&gt;用途是在为pods内部的应用程序提供访问Service Api的凭证,例如,获取某一namespace下的pods列表。&lt;/p&gt;

&lt;h3 id=&quot;角色和权限分配&quot;&gt;角色和权限分配&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: kubernetes-dashboard-minimal
  namespace: kube-system
rules:
  # Allow Dashboard to create 'kubernetes-dashboard-key-holder' secret.
- apiGroups: [&quot;&quot;]
  resources: [&quot;secrets&quot;]
  verbs: [&quot;create&quot;]
  # Allow Dashboard to create 'kubernetes-dashboard-settings' config map.

---------  

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: kubernetes-dashboard-minimal
  namespace: kube-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: kubernetes-dashboard-minimal
subjects:
- kind: ServiceAccount
  name: kubernetes-dashboard
  namespace: kube-system
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段配置把kubernetes-dashboard绑定到Role定义的权限设置里,规定它有权限操作的资源。&lt;/p&gt;

&lt;h1 id=&quot;部署&quot;&gt;部署&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kind: Deployment
apiVersion: apps/v1beta2
metadata:
  labels:
    k8s-app: kubernetes-dashboard
  name: kubernetes-dashboard
  namespace: kube-system
spec:
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      k8s-app: kubernetes-dashboard
  template:
    metadata:
      labels:
        k8s-app: kubernetes-dashboard
    spec:
      containers:
      - name: kubernetes-dashboard
        image: k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.0
        ports:
        - containerPort: 8443
          protocol: TCP
        args:
          - --auto-generate-certificates
          # Uncomment the following line to manually specify Kubernetes API server Host
          # If not specified, Dashboard will attempt to auto discover the API server and connect
          # to it. Uncomment only if the default does not work.
          # - --apiserver-host=http://my-address:port
        volumeMounts:
        - name: kubernetes-dashboard-certs
          mountPath: /certs
          # Create on-disk volume to store exec logs
        - mountPath: /tmp
          name: tmp-volume
        livenessProbe:
          httpGet:
            scheme: HTTPS
            path: /
            port: 8443
          initialDelaySeconds: 30
          timeoutSeconds: 30
      volumes:
      - name: kubernetes-dashboard-certs
        secret:
          secretName: kubernetes-dashboard-certs
      - name: tmp-volume
        emptyDir: {}
      serviceAccountName: kubernetes-dashboard
      # Comment the following tolerations if Dashboard must not be deployed on master
      tolerations:
      - key: node-role.kubernetes.io/master
        effect: NoSchedule
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Deployment 整合了上面定义的所有资源,包括Secret、AccountService。&lt;/p&gt;

&lt;p&gt;这部分是最容易出错的地方。有个issue整理了无法启动的原因&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/dashboard/issues/1578&quot;&gt;issue&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Creating API server client for https://10.96.0.1:443
Error while initializing connection to Kubernetes apiserver. This most likely means that the cluster is misconfigured (e.g., it has invalid apiserver certificates or service accounts configuration) or the --apiserver-host param points to a server that does not exist. Reason: Get https://10.96.0.1:443/version: dial tcp 10.96.0.1:443: i/o timeout
Refer to the troubleshooting guide for more information: https://github.com/kubernetes/dashboard/blob/master/docs/user-guide/troubleshooting.md

10.96.0.1 是Service Api 的cluster IP

k8snode-03@A11131221040327:~/.kube$ kubectl get service
NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.96.0.1    &amp;lt;none&amp;gt;        443/TCP   19h

k8snode-03@A11131221040327:~/.kube$ kubectl describe service kubernetes
Name:              kubernetes
Namespace:         default
Labels:            component=apiserver
                   provider=kubernetes
Annotations:       &amp;lt;none&amp;gt;
Selector:          &amp;lt;none&amp;gt;
Type:              ClusterIP
IP:                10.96.0.1
Port:              https  443/TCP
TargetPort:        6443/TCP
Endpoints:         192.168.12.39:6443
Session Affinity:  None
Events:            &amp;lt;none&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后,获取某一account的token&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用proxy访问dashboard&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl proxy

输出
Starting to serve on 127.0.0.1:8001 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>mikezhang</name></author><category term="kubernetes" /><summary type="html">Kubeternetes Dashboatd 安装手记</summary></entry><entry><title type="html">[GCE]单节点部署kubernetes集群</title><link href="http://localhost:4000/k8s-from-scrach" rel="alternate" type="text/html" title="[GCE]单节点部署kubernetes集群" /><published>2018-10-10T19:20:11+08:00</published><updated>2018-10-10T19:20:11+08:00</updated><id>http://localhost:4000/k8s-from-scrach</id><content type="html" xml:base="http://localhost:4000/k8s-from-scrach">&lt;p&gt;使用kubeadm部署单master节点的k8s, 1个master + 2个minion&lt;/p&gt;

&lt;h3 id=&quot;1-安装docker以及master节点初始化&quot;&gt;1. 安装Docker以及Master节点初始化&lt;/h3&gt;

&lt;p&gt;安装docker&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt install docker.io

sudo systemctl enable docker

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装kubeadm&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update \
  &amp;amp;&amp;amp; sudo apt-get install -y apt-transport-https \
  &amp;amp;&amp;amp; curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -

# k8s的资源暂不可用,使用16.04的更新资源 (xenial)
echo &quot;deb http://apt.kubernetes.io/ kubernetes-xenial main&quot; \
  | sudo tee -a /etc/apt/sources.list.d/kubernetes.list \
  &amp;amp;&amp;amp; sudo apt-get update

sudo apt install -y kubeadm  kubelet kubernetes-cni

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关闭交换分区&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo swapoff -a 
sudo rm -f /swapfile
sudo vi /etc/fstab   # 注释点 /swapfile 入口

sudo swapon --summary # 确认，如果没有输出，表明已经关闭
cat /proc/swaps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;关闭交换分区的原因，官方的说法是为了性能，设计者希望每个kubelet都可以实时响应&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/53533&quot;&gt;Kubelet/Kubernetes should work with Swap Enabled&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-初始化master节点&quot;&gt;2. 初始化master节点&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IP_ADDR=$(ip addr show eno1 | grep -Po 'inet \K[\d.]+')
echo $IP_ADDR

sudo kubeadm init --pod-network-cidr=192.168.0.0/16 --apiserver-advertise-address=${IP_ADDR} --kubernetes-version stable-1.2.1

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;cidr是一个很重要的概念，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1&quot;&gt;推荐阅读&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CIDR分配的网络资源是网段，而不是具体的地址。所以在AWS或常见云平台上申请网络资源时，先输入CIDR，比如10.1.0.0/16。16对应的子网掩码是255.255.0.0。&lt;/p&gt;

&lt;p&gt;默认的情况下，单个master节点是无法正常工作的，它不会分配pods资源。这里有个命令可以使master工作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl taint nodes --all node-role.kubernetes.io/master-
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;master节点被加入到了资源调度里面去。&lt;/p&gt;

&lt;h3 id=&quot;3-安装pod-network插件&quot;&gt;3. 安装Pod Network插件&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The network must be deployed before any applications. Also, CoreDNS will not start up before a network is installed. kubeadm only supports Container Network Interface (CNI) based networks (and does not support kubenet).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;网络组件有很多种，Flannel， Weave Net,Calico 等&lt;/p&gt;

&lt;p&gt;这里选择calico&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml
kubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果确认
kubectl get pods –all-namespaces&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;coredns在网络组建没有安装或者没有初始化完毕前是pending的状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-加入minion节点&quot;&gt;4. 加入Minion节点&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubeadm join 192.168.12.39:6443 --token 9uqyzo.y773su1b99kolayf --discovery-token-ca-cert-hash sha256:10ca82d1b6e3d9402b5243fa360e9c11a05320c1bd39989ab24aea1fcd6f8629
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段命令是kubeadm init以后给出的。&lt;/p&gt;

&lt;p&gt;–token 是节点加入凭证，如果忘记了，在master节点上可以重新获取&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubeadm token list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;顺利的话， join命令在几秒内就完成了。&lt;/p&gt;

&lt;p&gt;加入节点确认&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get nodes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5-遇到的问题&quot;&gt;5. 遇到的问题&lt;/h3&gt;

&lt;p&gt;在ubuntu18.04的版本里，默认CNI插件不兼容k8s 1.12,需要重新编译, 插件地址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/containernetworking/plugins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参考&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://k8smeetup.github.io/docs/admin/kubeadm/&quot;&gt;kubeadm 设置工具参考指南&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_34463875/article/details/78042852&quot;&gt;Kubenetes中的证书&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1s&quot;&gt;无类别域间路由&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/&quot;&gt;Creating a single master cluster with kubeadm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.projectcalico.org/v3.2/getting-started/kubernetes/&quot;&gt;Quickstart for Calico on Kubernetes&lt;/a&gt;&lt;/p&gt;</content><author><name>mikezhang</name></author><category term="automation" /><summary type="html">使用kubeadm部署单master节点的k8s, 1个master + 2个minion</summary></entry><entry><title type="html">在容器中使用Nuxt框架(docker-compose版)</title><link href="http://localhost:4000/vuejs-nuxjs-docker" rel="alternate" type="text/html" title="在容器中使用Nuxt框架(docker-compose版)" /><published>2018-10-10T19:20:11+08:00</published><updated>2018-10-10T19:20:11+08:00</updated><id>http://localhost:4000/vuejs-nuxjs-docker</id><content type="html" xml:base="http://localhost:4000/vuejs-nuxjs-docker">&lt;p&gt;为前端开发者提供一个boilerplate,内部持续推进版&lt;/p&gt;

&lt;h3 id=&quot;代码地址&quot;&gt;代码地址&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rmrfself/nuxt-docker&quot;&gt;https://github.com/rmrfself/nuxt-docker&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;特点&quot;&gt;特点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;生产环境与开发环境隔离&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用nginx反向代理，转发后端node&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过shell脚本生成ssl使用的自签名证书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用docker-compose一键启动&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用方法&quot;&gt;使用方法&lt;/h3&gt;

&lt;p&gt;1) 生成自签名证书&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;bash selfsigned.sh&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;输入自签名证书需要的组织信息。&lt;/p&gt;

&lt;p&gt;2) 把证书文件移到 ./certs 下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── zqh_CA.pem
├── zqh.crt.pem
├── zqh.csr
└── zqh.key.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3) 修改 ./config下的.env 文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ENVIRONMENT=dev
SSL_CERT_PATH=./certs/zqh.crt.pem
SSL_CERT_KEY_PATH=./certs/zqh.key.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4) 安装 node_modules&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;docker-compose run npm install&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;5) 启动容器服务&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;docker-compose -f docker-compose.yml -f docker-compose.dev.yml up&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;启动生产环境&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;cp config/dev.conf  config/prod.conf&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;docker-compose up&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;6) docker-compse ps 查看启动后的服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nuxt-js      npm run buildStart   Up       0.0.0.0:3000-&amp;gt;3000/tcp
nuxt-nginx   ./start.sh           Up       0.0.0.0:443-&amp;gt;443/tcp, 0.0.0.0:80-&amp;gt;80/tcp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>mikezhang</name></author><category term="kubernetes" /><summary type="html">为前端开发者提供一个boilerplate,内部持续推进版</summary></entry><entry><title type="html">搭建devops团队</title><link href="http://localhost:4000/devops-baseon-cloud" rel="alternate" type="text/html" title="搭建devops团队" /><published>2018-09-20T00:11:15+08:00</published><updated>2018-09-20T00:11:15+08:00</updated><id>http://localhost:4000/devops-baseon-cloud</id><content type="html" xml:base="http://localhost:4000/devops-baseon-cloud">&lt;p&gt;基于价值的软件交付流程&lt;/p&gt;

&lt;h3 id=&quot;devops-team&quot;&gt;Devops team&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.h5tube.com/aws-delivery.png&quot; alt=&quot;devops&quot; /&gt;&lt;/p&gt;

&lt;p&gt;#TODO&lt;/p&gt;</content><author><name>mikezhang</name></author><category term="nodejs" /><summary type="html">基于价值的软件交付流程</summary></entry><entry><title type="html">前端工程中的测试模型</title><link href="http://localhost:4000/archi-vuejs-test-model" rel="alternate" type="text/html" title="前端工程中的测试模型" /><published>2018-09-12T12:11:11+08:00</published><updated>2018-09-12T12:11:11+08:00</updated><id>http://localhost:4000/archi-vuejs-test-model</id><content type="html" xml:base="http://localhost:4000/archi-vuejs-test-model">&lt;h2 id=&quot;architecture-design&quot;&gt;Architecture Design&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.h5tube.com/cloud-front-end-archi.png&quot; alt=&quot;vuejs deployed into cloud&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;how-to-do-unit-test-based-on-vuejs-30&quot;&gt;How to do unit test based on vuejs-3.0&lt;/h3&gt;

&lt;p&gt;TODO&lt;/p&gt;</content><author><name>mikezhang</name></author><category term="nodejs" /><summary type="html">Architecture Design</summary></entry><entry><title type="html">如何快速的交付前端工程?</title><link href="http://localhost:4000/archi-vuejs-deploy" rel="alternate" type="text/html" title="如何快速的交付前端工程?" /><published>2018-09-11T17:14:11+08:00</published><updated>2018-09-11T17:14:11+08:00</updated><id>http://localhost:4000/archi-vuejs-deploy</id><content type="html" xml:base="http://localhost:4000/archi-vuejs-deploy">&lt;p&gt;前端工程的持续交付模型。&lt;/p&gt;

&lt;h3 id=&quot;designments&quot;&gt;Designments&lt;/h3&gt;

&lt;h4 id=&quot;基于vuejs的前端工程&quot;&gt;基于vuejs的前端工程&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.h5tube.com/vuejs-architecture.png&quot; alt=&quot;vuejs architecture&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;测试方法端到端测试单元测试集成测试&quot;&gt;测试方法(端到端测试、单元测试、集成测试)&lt;/h4&gt;

&lt;h4 id=&quot;云上交付&quot;&gt;云上交付&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.h5tube.com/cloud-front-end-archi.png&quot; alt=&quot;vuejs deployed into cloud&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;how-to-do-unit-test-based-on-vuejs-30&quot;&gt;How to do unit test based on vuejs-3.0&lt;/h4&gt;</content><author><name>mikezhang</name></author><category term="nodejs" /><summary type="html">前端工程的持续交付模型。</summary></entry><entry><title type="html">Ethereum开发笔记1-1: Blockchain简介</title><link href="http://localhost:4000/ethereum-dapp-develop" rel="alternate" type="text/html" title="Ethereum开发笔记1-1: Blockchain简介" /><published>2018-09-06T11:11:11+08:00</published><updated>2018-09-06T11:11:11+08:00</updated><id>http://localhost:4000/ethereum-dapp-develop</id><content type="html" xml:base="http://localhost:4000/ethereum-dapp-develop">&lt;p&gt;共识就是一起检查一个区块&lt;code class=&quot;highlighter-rouge&quot;&gt;是否&lt;/code&gt;有效。&lt;/p&gt;

&lt;h4 id=&quot;什么是工作量证明proof-of-work&quot;&gt;什么是工作量证明(proof of work)？&lt;/h4&gt;

&lt;p&gt;工作量证明的目的是使区块的创建变得困难，从而阻止女巫攻击者恶意重新生成区块链。&lt;/p&gt;

&lt;p&gt;从而确保了&lt;code class=&quot;highlighter-rouge&quot;&gt;链上&lt;/code&gt;价值存储的稳定性和不可篡改性。&lt;/p&gt;

&lt;p&gt;去中心化的各个节点之间是&lt;code class=&quot;highlighter-rouge&quot;&gt;通过异构体之间的共识&lt;/code&gt;机制来确保&lt;code class=&quot;highlighter-rouge&quot;&gt;不可篡改性&lt;/code&gt;。这是区块链的根。&lt;/p&gt;

&lt;p&gt;但是，问题是，单个节点通过什么手段来判定区块的合法性？&lt;/p&gt;

&lt;p&gt;目前主流有2种方法:&lt;/p&gt;

&lt;p&gt;1) 比特币使用POW,也就是工作量证明。&lt;/p&gt;

&lt;p&gt;只要一个台机器成功的按照规则(比特币是猜测前面含有N个0的Hash串)做到一件事情。把证据(nounce + 它对应的hash)打包入区块中。&lt;/p&gt;

&lt;p&gt;广播后，每个节点验证nounce 和 它对应的Hash是否正确，并唯一。 如果是，peer投赞同票。 否则拒绝了。&lt;/p&gt;

&lt;p&gt;这样的动作实现了一类共识。&lt;/p&gt;

&lt;p&gt;2）还有另外一种共识，基于权益的证明(Proof of stake)&lt;/p&gt;

&lt;p&gt;POS也是一种共识机制，用于区块的校验工作。它通过&lt;code class=&quot;highlighter-rouge&quot;&gt;下注&lt;/code&gt;的方式实现。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;验证者必须锁定一些他们拥有的币作为保证金。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在此之后，他们将开始验证区块。同时，当他们发现一个他们认为可以被加到链上的区块时，他们会通过下赌注来验证它。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果该区块成功上链，验证者就将得到一个与他们的赌注成比例的奖励。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;POS的优势&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;帮助实现分散化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;高能效&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;经济安全&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;扩展性&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;比特币中的区块链&quot;&gt;比特币中的区块链&lt;/h4&gt;

&lt;h5 id=&quot;比特币提出的背景&quot;&gt;比特币提出的背景&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;互联网上的贸易，几乎都需要借助金融机构作为可资信赖的第三方来处理电子支付信息。

虽然这类系统在绝大多数情况下都运作良好，但是这类系统仍然内生性地受制于“基于信用的
模式”(trust based model)的弱点。

我们无法实现完全不可逆的交易，因为金融机构总是不可避免地会出面协调争端。

而金融中介的存在，也会增加交易的成本，并且限制了实际可行的最小交易规模，也限制了日常的小额支付交易。

并且潜在的损失还在于，很多商品和服务本身是无法退货的，
如果缺乏不可逆的支付手段，互联网的贸易就大大受限。

因为有潜在的退款的可能，就需要交易双方拥有信任。

而商家也必须提防自己的客户，因此会向客户索取完全不必要的个人信息。

而实际的商业行为中，一定比例的欺诈性客户也被认为是不可避免的，相关损失视作销售费用处理。

而在使用物理现金的情况下，这些销售费用和支付问题上的不确定性却是可以避免的，因为此时没有第三方信用中介的存在。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;比特币系统背后的相关概念&quot;&gt;比特币系统背后的相关概念&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;交易(transactions): 区块链的存储属性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相关概念&lt;/p&gt;

&lt;p&gt;电子货币(electronic coin)是一串数字签名(digital signature):&lt;/p&gt;

&lt;p&gt;每一位所有者，通过对前一次交易(previous transactions)和下一位拥有者的公钥&lt;code class=&quot;highlighter-rouge&quot;&gt;签署&lt;/code&gt;一个数字签名，并将这个签名附加在货币的末尾， 电子货币就发送给了下一位所有者。&lt;/p&gt;

&lt;p&gt;收款人对签名进行检验，就可验证数字货币的拥有者。&lt;/p&gt;

&lt;p&gt;交易的唯一性确定&lt;/p&gt;

&lt;p&gt;通过Hash方法确保在交易期间，绝大多数节点认同该交易是首次出现。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;时间戳服务器:  链条是如何形成的?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;顾名思义， 对区块的内容实施随机散列，并且加上时间戳。&lt;/p&gt;

&lt;p&gt;该时间戳能够证实特定数据必然于某特定时间是的确存在的，因为只有在该时刻存在了才能获取相应的随机散列值。&lt;/p&gt;

&lt;p&gt;每个时间戳应当将前一个时间戳纳入其随机散列值中，每一个随后的时间戳都对之前的一个时间戳进行增强(reinforcing)，
这样就形成了一个链条（Chain）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;工作量证明(proof of work), 区块链不可篡改性背后的逻辑&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bitcoint中的实现方法是，增加一个nounce随机数字段:&lt;/p&gt;

&lt;p&gt;这个nounce的散列值具备这样的特性:  前N位是0。 通过这种形式的计算，挖矿者才不断的猜测这个nounce，一旦符合定义的条件(前N位是0)，它讲获得区块的记账权(数据&lt;code class=&quot;highlighter-rouge&quot;&gt;入链&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;所谓记账权，就是把交易(是全网内没有打包入块的交易)列表打包入区块。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;区块链网络&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;网络的运行方式如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;新的交易面向全网广播&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每一个节点都将收到的交易信息纳入一个区块中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当一个节点找到了一个工作量证明，它就向全网进行广播&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同
该区块的有效性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造
新的区块以延长该链条，而将被接受区块的随机散列值视为先于新区快的随机散列值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;激励&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比特币内存在如此约定:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对每一笔区块的&lt;code class=&quot;highlighter-rouge&quot;&gt;第一笔交易&lt;/code&gt;进行特殊化处理,该交易产生一枚有区块创造者(挖矿人)拥有的新的电子货币(bitcoin)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增加了节点支持该网络的激励。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提供了一种在没有中央集权机构发行货币的情况下，将电子货币分配到流通领域的一种方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另外一个激励来源是交易费。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blockchain.png&quot; alt=&quot;区块链结构&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;以太坊网络中的区块链&quot;&gt;以太坊网络中的区块链&lt;/h4&gt;

&lt;p&gt;以太坊项目提出的背景&lt;/p&gt;

&lt;p&gt;Etherem项目的提出是源与比特币的UTXO的不足之处。&lt;/p&gt;

&lt;p&gt;比特币系统的脚本语言存在一些严重的限制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;缺少图灵完备性， 简单理解是，可编程的能力非常弱。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Value-blindness，简单理解是，UTXO与复杂场景下的脚本不能友好地协作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺少状态，简单理解是，UTXO是个简单对象，为复杂可编程的脚本预留的空间很小。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Blockchain-blindness, 简单理解是， UTXO对象不包含链相关的上下文，无法与链上数据交互。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，为了弥补以上比特币脚本的缺陷， 以太坊实现了更复杂的脚本执行上下文， 这种脚本的另外一个名字是&lt;code class=&quot;highlighter-rouge&quot;&gt;智能合约&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;引用白皮书的一段概述&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;本项目旨在提取上述协议中的创新并将其通用化-创造一个功能完善的，图灵完备的（但是可深度自由调整的）加密账簿，它允许参与者编写任意复杂的完全存在于并且被块链传递的合约，自治代理和关系。用户可以把以太坊当成一种“金融积木”来用，而不是受限于某一特定的交易类型集合。

... 成为一个提供超强脚本系统的优秀底层协议，在其上可以创建任意高级的合约，货币及其它去中心化应用...

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ethereum区块链上的概念模型&quot;&gt;Ethereum区块链上的概念模型&lt;/h4&gt;

&lt;h5 id=&quot;以太坊账户模型&quot;&gt;以太坊账户模型&lt;/h5&gt;

&lt;p&gt;比特币也有账户的概念，就是UTXO. 它包含所有者以及价值信息。 系统中的交易有UTXO INPUT 和 UTXO OUTPUT 组成。&lt;/p&gt;

&lt;p&gt;比特币中一个账户的余额就是该用户的私钥能有效签名的所有UTXO的总和。&lt;/p&gt;

&lt;p&gt;Eth系统中，账户是一个20字节的地址，包含四个部分:&lt;/p&gt;

&lt;p&gt;1) 随机数， 用户确定每笔交易只能被处理一次。&lt;/p&gt;

&lt;p&gt;2) 余额&lt;/p&gt;

&lt;p&gt;3) 账户的合约代码&lt;/p&gt;

&lt;p&gt;4) 账户的存储&lt;/p&gt;

&lt;p&gt;它有两种类型的账户:&lt;/p&gt;

&lt;p&gt;1) 合约以外的账户，也成为外部账户，由私钥控制。外部账户没有代码，需要手动创建和签名一笔交易，然后发送消息。&lt;/p&gt;

&lt;p&gt;2) 合约账户。&lt;/p&gt;

&lt;p&gt;合约账户的能力比外部账户强大:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;它可以对内部存储进行读写。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;发送消息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建合约&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;eth的交易模型transactions&quot;&gt;Eth的交易模型(Transactions)&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;以太坊中“交易”是指存储从外部账户发出的消息的签名数据包。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Eth的交易是签名后的消息。&lt;/p&gt;

&lt;p&gt;1) 以太坊的消息可以由外部实体或者合约创建，然而比特币的交易只能从外部创建。&lt;/p&gt;

&lt;p&gt;2) 以太坊消息可以选择包含数据。&lt;/p&gt;

&lt;p&gt;3) 如果以太坊消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念。&lt;/p&gt;

&lt;h5 id=&quot;eth中的状态转换函数&quot;&gt;Eth中的状态转换函数&lt;/h5&gt;

&lt;p&gt;简单理解，这个eth处理交易的一个&lt;code class=&quot;highlighter-rouge&quot;&gt;事务&lt;/code&gt;。 步骤是固定的:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1) 检查交易的格式是否正确（即有正确数值）、签名是否有效和随机数是否与发送者账户的随机数匹配。

如否，返回错误。

2) 计算交易费用:fee=STARTGAS * GASPRICE，并从签名中确定发送者的地址。

从发送者的账户中减去交易费用和增加发送者的随机数。如果账户余额不足，返回错误。

3) 设定初值GAS = STARTGAS，并根据交易中的字节数减去一定量的瓦斯值。

4) 从发送者的账户转移价值到接收者账户。如果接收账户还不存在，创建此账户。

5) 如果接收账户是一个合约，运行合约的代码，直到代码运行结束或者瓦斯用完。

如果因为发送者账户没有足够的钱或者代码执行耗尽瓦斯导致价值转移失败，

恢复原来的状态，但是还需要支付交易费用，交易费用加至矿工账户。

否则，将所有剩余的瓦斯归还给发送者，消耗掉的瓦斯作为交易费用发送给矿工。 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>mikezhang</name></author><category term="ethereum" /><summary type="html">共识就是一起检查一个区块是否有效。</summary></entry><entry><title type="html">Guideline-编写有效率的javascript代码</title><link href="http://localhost:4000/archi-efficient-js" rel="alternate" type="text/html" title="Guideline-编写有效率的javascript代码" /><published>2018-08-09T12:11:19+08:00</published><updated>2018-08-09T12:11:19+08:00</updated><id>http://localhost:4000/archi-efficient-js</id><content type="html" xml:base="http://localhost:4000/archi-efficient-js">&lt;p&gt;Trust yourself, not the VM。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对象的初始化顺序&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    function Point(x, y) {
        this.x = x;
        this.y = y;
    }

    var p1 = new Point(11,12);
    var p1 = new Point(33,34);

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://&quot;&gt;nodejs中的隐藏类的生成方式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Checklist:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;成员变量写在构造函数内&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不要在其他地方任意添加成员变量或者方法&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Why:&lt;/p&gt;

&lt;p&gt;每当有新变量添加的时候, 编译器会生成一个新的隐藏类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.h5tube.com/nodejs-hiddenclass.png&quot; alt=&quot;Google I/O 2012&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;整数变量的使用&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = 1;
...
a = 1.5;
...
a = 'abcd';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Checklist:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a变量的重新赋值会引起 object a在内存中的被重新 allocation&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;数组的用法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Checklist:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用从0开始的连续下标&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a[5000] = 1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面表达式将促使编译器把变量a转化为一个字典类型&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不要删除数组中的元素，特别是numberic类型&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var data = [1,2,3,4];

delete data[2];

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面delete表达式会促使编译器把data转化为dictionary。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不要使用未初始化的数组元素&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = [];

for(var i = 0; i &amp;lt; 10; i ++) {
    a[0] = i; //   
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = [];

a[0] = 0; // ⬲⬲ 至少快2倍

for(var i = 0; i &amp;lt; 10; i ++) {
    a[0] = i; //   
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;注意数组元素的类型转化&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// First step
var a = new array();

a[0] = 77;
a[1] = 88;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.h5tube.com/nodejs-array-class-01.png&quot; alt=&quot;integer in array&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Second step
a[2] = 0.5;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.h5tube.com/nodejs-array-class-02.png&quot; alt=&quot;integer in array&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Third step
a[3] = true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.h5tube.com/nodejs-array-class-03.png&quot; alt=&quot;bad thing&quot; /&gt;&lt;/p&gt;

&lt;p&gt;更好的方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//一次性初始化
var data = [1,2,0.5, true];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;方法的使用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;充分利用IC(inline cache)&lt;/p&gt;

&lt;p&gt;Checklist:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;避免多态&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function add(x, y) {
    return x + y;
}

add(1, 2) // 生成单态隐藏类 monomorphic
add(&quot;a&quot;,&quot;b&quot;) // 多态 polymorphic

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=UJPdhx5zTaw&quot;&gt;Google I/O 2012 - Breaking the JavaScript Speed Limit with V8&lt;/a&gt;&lt;/p&gt;</content><author><name>mikezhang</name></author><category term="nodejs" /><summary type="html">Trust yourself, not the VM。</summary></entry><entry><title type="html">Devops那些事-虚拟化讲座讲义</title><link href="http://localhost:4000/devops-docker-presentation" rel="alternate" type="text/html" title="Devops那些事-虚拟化讲座讲义" /><published>2017-11-22T10:01:19+08:00</published><updated>2017-11-22T10:01:19+08:00</updated><id>http://localhost:4000/devops-docker-presentation</id><content type="html" xml:base="http://localhost:4000/devops-docker-presentation">&lt;p&gt;docker基础讲座讲义&lt;/p&gt;

&lt;h4 id=&quot;讲座内容&quot;&gt;讲座内容&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/01.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/03.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/04.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/05.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/06.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/07.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/08.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/09.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/10.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/11.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/12.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/13.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rmrfself/devpos-presentation-01/master/14.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>mikezhang</name></author><category term="automation" /><summary type="html">docker基础讲座讲义</summary></entry></feed>